<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Java八股文 | ZZMR</title><meta name="keywords" content="面试"><meta name="author" content="定西"><meta name="copyright" content="定西"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Java八股文"><meta name="application-name" content="Java八股文"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Java八股文"><meta property="og:url" content="https://jimmy66886.github.io/posts/7b3d68.html"><meta property="og:site_name" content="ZZMR"><meta property="og:description" content="贝贝!"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img01.zzmr.club/img/拾光_贪食鬼_6652.jpg"><meta property="article:author" content="定西"><meta property="article:tag" content="个人博客"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img01.zzmr.club/img/拾光_贪食鬼_6652.jpg"><meta name="description" content="贝贝!"><link rel="shortcut icon" href="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg"><link rel="canonical" href="https://jimmy66886.github.io/posts/7b3d68"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3e49559454d4932941707cbfc1458970";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"404 Not Found","backTitle":"500 Internal Server Error"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.zzmr.club/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: false,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: {"appId":"F9JLPTATA5","apiKey":"59b226541195bbf63bef817349ad87b5","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 定西","link":"链接: ","source":"来源: ZZMR","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'ZZMR',
  title: 'Java八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-11-18 20:07:36',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/about-tag.css"><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://index.zzmr.club/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/HOMEMESSAGE.png" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.zzmr.club/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">工具</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://tools.zzmr.club/" title="图床容量"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/github-alt.png" alt="图床容量"/><span class="back-menu-item-text">图床容量</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">ZZMR</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/maps/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 导航</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 游戏人生</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/staticIndex/test.html"><i class="anzhiyufont anzhiyu-icon-rocket faa-tada" style="font-size: 0.9em;"></i><span> 舔狗日记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://img01.zzmr.club/img/chatpay.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/chatpay.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img01.zzmr.club/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> <span>最新评论</span></span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 1.05rem;">AOP<sup>1</sup></a><a href="/tags/Ajax/" style="font-size: 1.05rem;">Ajax<sup>1</sup></a><a href="/tags/Algolia/" style="font-size: 1.05rem;">Algolia<sup>1</sup></a><a href="/tags/Axios/" style="font-size: 1.05rem;">Axios<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>1</sup></a><a href="/tags/MySql/" style="font-size: 1.05rem;">MySql<sup>2</sup></a><a href="/tags/Promise/" style="font-size: 1.05rem;">Promise<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>1</sup></a><a href="/tags/SSM/" style="font-size: 1.05rem;">SSM<sup>3</sup></a><a href="/tags/Shell/" style="font-size: 1.05rem;">Shell<sup>1</sup></a><a href="/tags/SpingBoot/" style="font-size: 1.05rem;">SpingBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 1.05rem;">SpringCloud<sup>1</sup></a><a href="/tags/VsCode/" style="font-size: 1.05rem;">VsCode<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>1</sup></a><a href="/tags/mag68/" style="font-size: 1.05rem;">mag68<sup>1</sup></a><a href="/tags/maven/" style="font-size: 1.05rem;">maven<sup>1</sup></a><a href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" style="font-size: 1.05rem;">主从复制<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">图床<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D/" style="font-size: 1.05rem;">域名<sup>1</sup></a><a href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 1.05rem;">年度总结<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">开发<sup>1</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 1.05rem;">排序<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem;">旅行<sup>5</sup></a><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">杂谈<sup>1</sup></a><a href="/tags/%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/" style="font-size: 1.05rem;">标签外挂<sup>1</sup></a><a href="/tags/%E6%AF%95%E8%AE%BE/" style="font-size: 1.05rem;">毕设<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">线程<sup>1</sup></a><a href="/tags/%E7%BE%8E%E5%8C%96/" style="font-size: 1.05rem;">美化<sup>1</sup></a><a href="/tags/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/" style="font-size: 1.05rem;">苍穹外卖<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 1.05rem;">集合<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>7</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" onclick="anzhiyu.switchDarkMode()" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/" itemprop="url">JAVA</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Java八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-27T13:34:22.000Z" title="发表于 2023-09-27 21:34:22">2023-09-27</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-11-18T12:07:36.511Z" title="更新于 2023-11-18 20:07:36">2023-11-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span id="" data-flag-title="Java八股文"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="twikoo_visitors" title="访问量"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为汉中"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>汉中</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://img01.zzmr.club/img/拾光_贪食鬼_6652.jpg"></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://jimmy66886.github.io/posts/7b3d68.html"><header><a class="post-meta-categories" href="/categories/JAVA/" itemprop="url">JAVA</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">Java八股文</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">定西</span><time itemprop="dateCreated datePublished" datetime="2023-09-27T13:34:22.000Z" title="发表于 2023-09-27 21:34:22">2023-09-27</time><time itemprop="dateCreated datePublished" datetime="2023-11-18T12:07:36.511Z" title="更新于 2023-11-18 20:07:36">2023-11-18</time></header><p>现代八股</p>
<h1 id="1-Redis篇"><a href="#1-Redis篇" class="headerlink" title="1 Redis篇"></a>1 Redis篇</h1><ol>
<li>Redis使用场景<ul>
<li><strong>缓存(穿透,击穿,雪崩 | 双写一致,持久化 | 数据过期,淘汰策略)</strong></li>
<li><strong>分布式锁(setnx,re’disson)</strong></li>
<li>计数器</li>
<li>保存token</li>
<li>消息队列</li>
<li>延迟队列</li>
</ul>
</li>
</ol>
<hr>
<h2 id="1-1-缓存穿透"><a href="#1-1-缓存穿透" class="headerlink" title="1.1 缓存穿透"></a>1.1 缓存穿透</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA023-09-2601017.jpg" alt="屏幕截023-09-2601017"></p>
<p>例如,一个get请求: <code>api/new/getById/1</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926101238.png" alt="20230926101238"></p>
<p><strong>缓存穿透</strong>:查询一个<strong>不存在</strong>的数据,mysql查询不到数据也不会直接写入缓存,就会导致每次请求都查数据库</p>
<p><em>穿透穿透,可以理解为请求的数据穿透了redis,还是动用了mysql,导致缓存没起到作用</em></p>
<p><strong>解决方案一</strong>:缓存空数据,查询返回的数据为空,扔把这个空结果进行缓存<br><strong>优点</strong>:简单<br><strong>缺点</strong>:消耗内存,可能会发生不一致的问题</p>
<p><strong>解决方案二</strong>:布隆过滤器<br><strong>优点</strong>:内存占用较少,没有多余的key<br><strong>缺点</strong>:实现复杂,存在误判<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926101827.png" alt="20230926101827"></p>
<blockquote>
<p><strong>布隆过滤器</strong><br>bitmap(位图):相当于一个以(bit)位为单位的数组,数组中每个单元只能存储二进制数0或1<br>布隆过滤器的作用:布隆过滤器可以用于检索一个元素是否在一个集合中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20102348.png" alt="2023-09-26102348"><br>两种实现:redisson,guava</p>
</blockquote>
<p>但是布隆过滤器也存在误判的可能<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926102614.png" alt="20230926102614"><br><strong>误判率</strong>:数组越小误判率就越大,数组越大误判率就越小,但是同时也带来了更多的内存消耗</p>
<h2 id="1-2-缓存击穿"><a href="#1-2-缓存击穿" class="headerlink" title="1.2 缓存击穿"></a>1.2 缓存击穿</h2><p><strong>缓存击穿</strong>:给某<strong>一个</strong>key设置了过期时间,当key过期的时候,恰好这时间点对这个key有大量的并发请求过来,这些并发的请求可能会瞬间把DB压垮<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926125923.png" alt="20230926125923"></p>
<p>两种解决方案</p>
<ol>
<li>互斥锁<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926123451.png" alt="20230926123451"></li>
<li>逻辑过期<ul>
<li>判断数据是否逻辑过期</li>
<li>如已过期,获取互斥锁,开启新线程<ul>
<li>新线程中:查询数据库重建缓存数据</li>
<li>写入缓存,重置逻辑过期时间</li>
<li>释放锁</li>
</ul>
</li>
<li>返回过期数据(<strong>注意,此时的返回数据,并不需要等待新线程执行完毕,而是直接返回</strong>)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926124730.png" alt="20230926124730"></li>
</ul>
</li>
</ol>
<hr>
<p>互斥锁和逻辑过期的比较</p>
<ol>
<li>互斥锁<ul>
<li>强一执</li>
<li>性能差</li>
</ul>
</li>
<li>逻辑过期<ul>
<li>高可用</li>
<li>性能优</li>
</ul>
</li>
</ol>
<h2 id="1-3-缓存雪崩"><a href="#1-3-缓存雪崩" class="headerlink" title="1.3 缓存雪崩"></a>1.3 缓存雪崩</h2><p><strong>缓存雪崩</strong>是指在<strong>同一时段大量</strong>的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926130005.png" alt="20230926130005"></p>
<p>解决方案</p>
<ul>
<li>给不同的Key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性(哨兵模式,集群模式)</li>
<li>给缓存业务添加降级限流的策略(nginx,spring cloud gateway)</li>
<li>给业务添加多级缓存(Guava,Caffenie)</li>
</ul>
<p><strong>降级限流策略可作为系统的保底策略,适用于穿透,击穿,雪崩</strong></p>
<hr>
<blockquote>
<p>缓存三兄弟<br>穿透无中生有key,布隆过滤null隔离<br>缓存击穿过期key,锁与非期解难题<br>雪崩大量过期key,过期时间要随机<br>面试必考三兄弟,可用限流来保底</p>
</blockquote>
<h2 id="1-4-双写一致"><a href="#1-4-双写一致" class="headerlink" title="1.4 双写一致"></a>1.4 双写一致</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926131024.png" alt="20230926131024"></p>
<p>要结合业务背景,有两种情况</p>
<ol>
<li>一致性要求高</li>
<li>允许延迟一致</li>
</ol>
<h3 id="一致性要求高"><a href="#一致性要求高" class="headerlink" title="一致性要求高"></a>一致性要求高</h3><p><strong>双写一致性</strong>,当修改了数据库的数据也要同时更新缓存的数据,缓存和数据库的数据要保持一致</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926125923.png" alt="20230926125923"></p>
<ul>
<li>读操作:缓存命中,直接返回;缓存未命中则查询数据库,写入缓存,设定超时时间</li>
<li>写操作:延迟双删</li>
</ul>
<p><strong>先删除缓存,还是先修改数据库</strong></p>
<ol>
<li>先删除缓存<ul>
<li>正常情况:<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926131855.png" alt="20230926131855"></li>
<li>异常情况,数据不一致(数据库和缓存中的数据不一致)<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926131950.png" alt="20230926131950"></li>
</ul>
</li>
<li>先操作数据库<ul>
<li>正常情况:<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926132240.png" alt="20230926132240"></li>
<li>异常情况,数据不一致<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926132414.png" alt="20230926132414"></li>
</ul>
</li>
</ol>
<p>所以,无论是先删缓存,还是先修改数据库,都是会有问题的</p>
<p>这时采用<strong>延迟双删</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926132535.png" alt="20230926132535"></p>
<p><strong>虽然还是有脏数据的风险罢了</strong></p>
<p>那有没有强一致性的解决方案呢?</p>
<p><strong>分布式锁</strong></p>
<p>或者说是读写锁,只针对于需要强一致性的场景,因为性能低</p>
<ol>
<li>共享锁:读锁readLock,加锁之后,其他线程可以继续共享读操作</li>
<li>排他锁:独占锁writeLock也叫,加锁之后,阻塞其他线程读写操作<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926133140.png" alt="20230926133140"></li>
</ol>
<h3 id="允许延迟一致"><a href="#允许延迟一致" class="headerlink" title="允许延迟一致"></a>允许延迟一致</h3><p>异步通知保证数据的最终一致性<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926133556.png" alt="20230926133556"></p>
<p>基于Canal的异步通知<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926133620.png" alt="20230926133620"></p>
<p>canal是基于mysql的主从同步来实现的<br><code>二进制日志文件(BINGLOG)记录了所有DDL(数据定义语言)语句和DML(数据操作语言)语句,但不包括数据查询(SELECT,SHOW)语句</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/3123213213213213.png" alt="3123213213213213"></p>
<h2 id="1-5-持久化"><a href="#1-5-持久化" class="headerlink" title="1.5 持久化"></a>1.5 持久化</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926221020.png" alt="20230926221020"></p>
<ol>
<li>RDB</li>
<li>AOF</li>
</ol>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB全称Redis Database Backup file(Redis数据备份文件),也被叫做Redis数据快照,简单来说就是把内存中的所有数据都记录到磁盘中,当Redis实例故障重启后,从磁盘中读取快照文件,恢复数据<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926221331.png" alt="20230926221331"></p>
<p>Redis内部也有触发RDB的机制,可以在redis.conf中找到,格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p><strong>RDB执行原理?</strong><br>bgsave开始时会fork主进程得到子进程,子进程<strong>共享</strong>主进程的内存数据,完成fork后读取内存数据并写入RDB文件</p>
<p>fork采用的是copy-on-write技术</p>
<ul>
<li>当主进程执行读操作时,访问共享内存</li>
<li>当主进程执行写操作时,则会拷贝一份数据,执行写操作<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926222728.png" alt="20230926222728"></li>
</ul>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>AOF全称为Append Only File(追加文件),Redis处理的每一个写命令都会记录在AOF文件,可以看作命令日志文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/223022.png" alt="223022"></p>
<p>AOF默认是关闭的,要在配置文件中开启</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>AOF的同步频率设置</p>
<ul>
<li>appendfsync always 始终同步,每次Redis的写入都会立刻记入日志,性能较差但数据完整性比较好</li>
<li><strong>appendfsync everysec</strong> 每秒同步,每秒记入日志一次,如果宕机,本秒的数据可能丢失</li>
<li>appendfsync no redis不主动进行同步,把同步时机交给操作系统</li>
</ul>
<p>因为是记录命令,AOF文件会比RDB文件大的多,而且AOF会记录对同一个key的多次写操作,但只有最后一次写操作才有意义,通过执行 <code>bgrewriteaof</code>命令,可以让AOF文件执行重写功能,用最少的命令达到相同的效果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># AOF文件体积最小多大以上才出发重写</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>

<hr>
<p>总结就是,RDB和AOF各有自己的优缺点,如果对数据安全性要求较高,在实际开发中往往会结合两者来使用(这和之前看的redis视频讲的差不多)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926224811.png" alt="20230926224811"></p>
<h2 id="1-6-过期策略"><a href="#1-6-过期策略" class="headerlink" title="1.6 过期策略"></a>1.6 过期策略</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230926225503.png" alt="20230926225503"></p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>Redis数据删除策略-惰性删除</p>
<p>惰性删除:设置该key过期时间后,我们不去管它,当需要该key时,我们在检查其是否过期,如果过期,我们就删掉它,反之就返回该key</p>
<p><strong>优点</strong>:对CPU友好,只会在使用该key时才会进行过期检查,对于很多用不到的key不用浪费时间进行过期检查<br><strong>缺点</strong>:对内存不友好,如果一个key已过期,但是一直没有使用,那么该key就会一直存在内存中,内存永远不会释放</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>Redis数据删除策略-定期删除</p>
<p>定期删除:每隔一段时间,我们就对一些key进行检查,删除里面过期的key(从一定数量的数据库取出一定数量的随机key进行检查,并删除其中过期的key)</p>
<p>定期删除有两种模式</p>
<ol>
<li>SLOW模式是定时任务,执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis.conf的hz选项来调整这个次数</li>
<li>FAST模式执行频率不固定,但两次间隔不低于2ms,每次耗时不超过1ms</li>
</ol>
<p><strong>优点</strong>:可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响,另外定期删除,也能有效释放过期建占用的内存<br><strong>缺点</strong>:难以确定删除操作执行的时长和频率</p>
<hr>
<p>Redis的过期删除策略:惰性删除+定期删除两种策略进行配合使用</p>
<h2 id="1-7-淘汰策略"><a href="#1-7-淘汰策略" class="headerlink" title="1.7 淘汰策略"></a>1.7 淘汰策略</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927085536.png" alt="20230927085536"></p>
<p><strong>数据的淘汰策略</strong>:当Redis中的内存不够用时,此时再向Redis总添加新的key,那么Redis就会按照某一种规则讲内存中的数据删除掉,这种数据的删除规则被称之为内存的淘汰策略</p>
<p>Redis支持8种不同的策略来选择要删除的key</p>
<ul>
<li><code>noeviction</code>:不淘汰任何key,但是内存满时不允许写入新数据,默认就是这种策略</li>
<li><code>volatile-ttl</code>:对设置了TTL的key,比较key的剩余TTL值,TTL越小越先被淘汰</li>
<li><code>allkeys-random</code>:对全体key,随机进行淘汰</li>
<li><code>volatile-random</code>:对设置了TTL的key,进行随机淘汰</li>
<li><code>allkeys-lru</code>:对全体key,基于LRU算法进行淘汰</li>
<li><code>volatile-lru</code>:对设置了TTL的key,基于LRU算法进行淘汰</li>
<li><code>allkeys-lfu</code>:对全体key,基于LFU算法进行淘汰</li>
<li><code>volatile-lfu</code>:对设置了TTL的key,基于LFU算法进行淘汰</li>
</ul>
<hr>
<p>使用建议</p>
<ol>
<li>优先使用 <code>allkeys-lru</code>策略,充分利用LRU算法的优势,把最近最长访问的数据流在缓存中,如果业务有明显的冷热数据区分,建议使用</li>
<li>如果业务中数据访问频率差别不大,没有明显的冷热数据区分,建议使用 <code>allkeys-random</code>,随机选择淘汰</li>
<li>如果业务中有置顶的需求,可以使用 <code>volatile-lru</code>策略,同时置顶数据不设置过期时间,这些数据就一直不被删除,会淘汰其他设置过期时间的数据</li>
<li>如果业务中有短时高频访问的数据,可以使用 <code>allkeys-lfu</code>或 <code>volatile-lfu</code>策略</li>
</ol>
<hr>
<p>其他可能会问的问题</p>
<ol>
<li>数据库有1000万数据,Redis只能缓存20W数据,如何保证Redis种的数据都是热点数据?</li>
</ol>
<p><strong>使用 <code>allkeys-lru</code>(挑选最近最少未使用的数据淘汰)淘汰策略,留下来的都是经常访问的热点数据</strong></p>
<ol start="2">
<li>Redis的内存用完了会发生什么<br>主要看数据淘汰策略是什么,如果是默认的配置(<code>noeviction</code>),会直接报错</li>
</ol>
<h2 id="1-8-分布式锁"><a href="#1-8-分布式锁" class="headerlink" title="1.8 分布式锁"></a>1.8 分布式锁</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927091744.png" alt="20230927091744"></p>
<p><strong>当只有一台服务器时,使用 <code>synchronized</code>解决是没问题的,但是当服务是多台服务器时,就不能使用了,还是需要外部锁的来解决</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-09-27092743.png" alt="23-09-27092743"></p>
<p><strong>Redis分布式锁</strong><br>Redis实现分布式锁主要利用Redis的setnx命令,setnx是set if no exists(如果不存在,则set)</p>
<p>获取锁,NX是互斥,EX是设置过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock value NX EX 10</span><br></pre></td></tr></table></figure>

<p>释放锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key</span><br></pre></td></tr></table></figure>

<p>整体流程:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927145211.png" alt="20230927145211"></p>
<p>设置有效时长<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927145426.png" alt="20230927145426"></p>
<ol>
<li>根据业务执行时间预估</li>
<li>给锁续期</li>
</ol>
<hr>
<p>这时就要用到 <code>redisson</code>来实现分布式锁</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/123132150213.png" alt="123132150213"></p>
<p>redisson实现的分布式锁-可重入<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927150634.png" alt="20230927150634"></p>
<p>redisson实现的分布式锁-主从一致性(较少使用)<br>RedLock(红锁):不能只在一个redis实力上创建锁,应该是在多个redis实例上创建锁(n&#x2F;2+1),避免在一个redis实例上加锁<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927151015.png" alt="20230927151015"></p>
<ul>
<li>实现复杂</li>
<li>性能差</li>
<li>运维繁琐</li>
</ul>
<h2 id="1-9-集群方案"><a href="#1-9-集群方案" class="headerlink" title="1.9 集群方案"></a>1.9 集群方案</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927151710.png" alt="20230927151710"></p>
<ul>
<li>主从复制</li>
<li>哨兵模式</li>
<li>分片集群</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>单节点Redis的并发能力是有上限的,要进一步提高Redis的并发能力,就需要搭建主从集群,实现读写分离</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-09-27152040.png" alt="2023-09-27152040"></p>
<p><strong>分为全量同步和增量同步</strong></p>
<p>增量同步:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-27%20153922.png" alt="153922"></p>
<p>增量同步(slave重启或者后期数据变化):<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927154218.png" alt="20230927154218"></p>
<p>回答案例:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927154511.png" alt="20230927154511"></p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复,哨兵的结构和作用如下</p>
<ol>
<li>监控:Sentinel会不端检查您的master和slave是否按预期工作</li>
<li>自动故障恢复:如果master故障,Sentinel会将一个slave提升为master,当故障实例恢复后也以新的master为主</li>
<li>通知:Sentinel充当Redis客户端的服务发现来源,当集群发生故障转移时,会将最新信息推送给Redis客户端<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927154951.png" alt="20230927154951"></li>
</ol>
<p><strong>服务转台监控</strong><br>Sentinel基于心跳机制监测服务状态,每隔1s向集群的每个实例发送ping命令</p>
<ol>
<li>主观下线:如果其sentinel节点发现某实例未在规定时间响应,则认为该实例<strong>主观下线</strong></li>
<li>客观下线:若超过指定数量(quorum)的sentinel都认为该实例主观下线,则该实例客观<strong>下线</strong>,quorum值最好超过Sentinel实例数量的一半<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927155336.png" alt="20230927155336"></li>
</ol>
<p><strong>下线后,哨兵就要选择一个从节点作为主节点</strong></p>
<ol>
<li>首先判断主与从节点断开时间长短,如超过指定值就排该从节点</li>
<li>然后判断从节点的slave-priority值,越小优先级越高</li>
<li><strong>如果slave-prority一样,则判断slave节点和offset值,越大优先级越高</strong></li>
<li>最后是判断slave节点的运行id大小,越小优先级越高</li>
</ol>
<hr>
<p>哨兵模式,可能存在的问题:<strong>脑裂</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927160007.png" alt="20230927160007"></p>
<p>redis中有两个配置参数<br><code>min-replicas-to-write 1</code>表示最少的slave节点为1个<br><code>min-replicas-max-lag 5</code>表示数据复制和同步的延迟不能超过5秒</p>
<p>设置了这两个参数的,当主节点宕机,不达到这两个条件,是不会选择新的主机的.</p>
<h3 id="分片集群结构"><a href="#分片集群结构" class="headerlink" title="分片集群结构"></a>分片集群结构</h3><p>主从和哨兵可以解决高可用，高并发读的问题，但是依然有两个问题没有解决</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可以解决上述问题，分片集群特征</p>
<ol>
<li>集群中有多个master，每个master保存不同的数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927205512.png" alt="20230927205512"></li>
</ol>
<hr>
<p>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽,集群的每个节点负责一部分hash槽<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE2023-09-27210240.png" alt="屏幕截图2023-09-27210240"></p>
<h2 id="1-10-Redis其他问题"><a href="#1-10-Redis其他问题" class="headerlink" title="1.10 Redis其他问题"></a>1.10 Redis其他问题</h2><p><strong>Redis为什么这么快</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230927210522.png" alt="20230927210522"></p>
<p><strong>I&#x2F;O多路复用模型</strong><br>Redis是纯内存操作,执行速度非常快,它的性能瓶颈是<strong>网络延迟</strong>而不是执行速度,I&#x2F;O多路复用模型主要就是实现了高校的网络请求</p>
<p>I&#x2F;O多路复用是利用单个线程来同时监听多个Socket,并在某个Socket可读,可写时得到通知,从而避免无效的等待,充分利用CPU资源,不过监听Socket的方式,通知的方式又有多种实现,常见的有</p>
<ol>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ol>
<p><strong>差异</strong></p>
<ul>
<li>select和poll只会通知用户进程有Socket就绪,但不确定具体是哪一个Socket,需要用户进程逐个遍历Socket来确认</li>
<li>epoll则会在通知用户进程Socket就绪的同时,把已就绪的Socket写入用户空间</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/fdlkajlksfdjlkasf.png" alt="fdlkajlksfdjlkasf"></p>
<h1 id="2-数据库篇"><a href="#2-数据库篇" class="headerlink" title="2 数据库篇"></a>2 数据库篇</h1><p>看完了索引那块,这块内容就能很快看完了吧</p>
<h2 id="2-1-优化篇"><a href="#2-1-优化篇" class="headerlink" title="2.1 优化篇"></a>2.1 优化篇</h2><p><strong>如何定位慢查询</strong></p>
<ol>
<li>调试工具:<code>Arthas</code></li>
<li>运维工具:<code>Prometheus,Skywalking</code></li>
<li>mysql自带的慢查询日志功能,<a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/a91f5ba1.html#11-3-%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84sql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">配置流程</a></li>
</ol>
<hr>
<p><strong>一条Sql执行的很慢,如何分析呢?</strong></p>
<ul>
<li>聚合查询</li>
<li>多表查询</li>
<li>表数据过大查询</li>
<li>深度分页查询</li>
</ul>
<p>使用Explain来查看sql是否有问题</p>
<ol>
<li>查看索引是否失效</li>
<li>查看是否有优化空间</li>
<li><strong>覆盖索引</strong></li>
</ol>
<hr>
<p><strong>介绍索引</strong></p>
<ol>
<li>索引是帮助mysql高效获取数据的数据结构</li>
<li>提高数据的检索效率,降低数据库的IO成本</li>
<li>通过索引列对数据进行排序,降低数据排序成本,降低CPU的消耗</li>
</ol>
<hr>
<p><strong>B+树</strong></p>
<ol>
<li>路径短</li>
<li>磁盘读写代价B+树低,非叶子节点不存储数据,叶子节点存储数据</li>
<li>B+树便于扫库和区间查询,叶子节点是一个双向链表</li>
</ol>
<hr>
<p><strong>聚簇索引以及非聚簇索引</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/a91f5ba1.html#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95">索引类型</a></p>
<p>简单来说,聚簇索引就是数据和索引放到了一棵B+树中,叶子节点包含了所有的数据</p>
<p>非聚簇索引:叶子节点只包含索引列以及主键值</p>
<p><strong>回表</strong>:使用二级索引时,根据二级索引拿到主键值,再用主键值根据聚簇索引来回表查询</p>
<hr>
<p><strong>覆盖索引</strong><br><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/a91f5ba1.html#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95">简单来说,索引列+主键包含SELECT到FROM之间查询的列</a></p>
<p><strong>尽量避免</strong> <code>select*</code></p>
<p><strong>mysql超大分页怎么处理</strong><br>可以使用覆盖索引+子查询</p>
<p>先通过id对表数据进行排序,这里就用到了覆盖索引(或者说是聚簇索引),效率很高<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/10-13190402.jpg" alt="10-13190402"></p>
<hr>
<p><strong>索引创建的原则</strong></p>
<ol>
<li>针对于数据量较大,且查询比较频繁的表建立索引(单表超过10万)</li>
<li>针对于常作查询条件(where),排序(order by),分组(group by)操作的字段建立索引</li>
<li>尽量选择区分度较高的列作为索引</li>
<li>如果字段的类型是字符串,且长度较长,可以针对字段的特点,建立<a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/a91f5ba1.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E7%BC%80%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95">前缀索引</a></li>
<li>尽量使用联合索引,减少单列索引,查询时,联合索引很多时候可以实现覆盖索引,节省存储空间,避免回表,提高查询效率</li>
<li>控制索引的数量,因为索引会影响增删改的效率</li>
</ol>
<hr>
<p><strong>索引失效</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/a91f5ba1.html#12-2-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B">失效案例</a></p>
<hr>
<p><strong>sql优化的经验</strong></p>
<ol>
<li>表设计优化</li>
<li>索引优化</li>
<li>sql语句优化</li>
<li>主从复制,读写分离</li>
<li>分库分表</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-13200233.jpg" alt="2023-10-13200233"></p>
<h2 id="2-2-其他面试题"><a href="#2-2-其他面试题" class="headerlink" title="2.2 其他面试题"></a>2.2 其他面试题</h2><h3 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h3><p>事务是一组操作的集合,它是一个不可分割的工作单位,事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求,即这样操作要么同时成功,要么同时失败</p>
<p><strong>ACID</strong></p>
<ul>
<li>原子性(Atomicity):事务是不可分割的最小操作单元,要么全部成功,要么全部失败</li>
<li>一致性(Consistency):事务完成时,必须使所有的数据都保持一致状态</li>
<li>隔离性(Isolation):数据库系统提供的隔离机制,保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability):事务一旦提交或回滚,它对数据库中的数据的改变就是永久的</li>
</ul>
<hr>
<p><strong>并发事务带来的问题</strong>:脏读,不可重复读,幻读<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-13202107.jpg" alt="2023-10-13202107"></p>
<p><strong>隔离级别</strong>:读未提交,读已提交,<strong>可重复读</strong>,串行化</p>
<hr>
<p><strong>undo log和redo log</strong>的区别<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-1310455.jpg" alt="2023-10-1310455"></p>
<ul>
<li>缓冲池(buffer poll):主内存中的一个区域,里面可以缓存磁盘上经常操作的真实数据,在执行增删改查操作时,先操作缓存池中的数据(若缓冲池没有数据,则从磁盘加载并缓存),以一定频率刷新到磁盘,从而减少磁盘IO,加快处理速度</li>
<li>数据页(page):是InnoDB存储引擎磁盘管理的最小单元,每个页的大小默认为16KB,页中存储的是行数据</li>
</ul>
<blockquote>
<p>redo log<br>重做日志,记录的是事务提交时数据页的物理修改,是<strong>用来实现事务的持久性</strong><br>该日志文件由两部分组成</p>
</blockquote>
<ol>
<li>重做日志缓存(redo log buffer),内存中</li>
<li>重做日志文件(redo log file),磁盘中</li>
</ol>
<p>当事务提交之后会把所有修改信息都存放到该日志文件中,用于在刷新脏页到磁盘,发生错误时,进行数据恢复使用</p>
<blockquote>
<p>undo log<br>回滚日志,用于记录数据被修改前的信息,作用包含两个:<strong>提供回滚</strong>和<strong>MVCC</strong>(多版本并发控制),undo log和redo log记录物理日志不一样,它是<strong>逻辑日志</strong></p>
</blockquote>
<ul>
<li>可以认为当delete一条记录时,undo log中会记录一条对应的insert记录,反之依然</li>
<li>当update一条记录时,它记录一条对应相反的update记录,当执行rollback时,就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</li>
</ul>
<p><strong>undo log</strong>可以实现事务的一致性和原子性</p>
<hr>
<p><strong>事务的隔离性是如何保证的呢?</strong></p>
<ul>
<li>锁:排他锁(如一个事务获取了一个数据行的排他锁,其他事务就不能再获取该行的其他锁)</li>
<li>mvcc:多版本并发控制</li>
</ul>
<blockquote>
<p>MVCC-实现原理</p>
</blockquote>
<ul>
<li>记录中的隐藏字段<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-13211625.jpg" alt="023-10-13211625"></li>
</ul>
<p>回滚日志,在insert,update,delete的时候产生的便于数据回滚的日志<br>当insert的时候,产生的undo log日志只在回滚时需要,在事务提交后,可被立即删除<br>而update,delete的时候,产生的undo log日志不仅在回滚时需要,mvcc版本访问也需要,不会立即被删除</p>
<p>??????</p>
<p><strong>这个mvcc抽空看看mysql的课吧</strong></p>
<h3 id="主从同步原理"><a href="#主从同步原理" class="headerlink" title="主从同步原理"></a>主从同步原理</h3><p>mysql主从复制的核心就是二进制日志文件</p>
<p>二进制日志 <code>BINLOG</code>记录了所有DDL(数据定义语言)语句和DML(数据操纵语言)语句,但不包括数据查询(SELECT,SHOW)语句</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-13446.jpg" alt="023-10-13446"></p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>这个只有数据量特别大的时候才会用到</p>
<p><strong>记住垂直是分结构,水平是分数据</strong></p>
<h1 id="3-框架篇"><a href="#3-框架篇" class="headerlink" title="3 框架篇"></a>3 框架篇</h1><p><em>花了三天把课程设计给写了写</em></p>
<h2 id="3-1-Spring"><a href="#3-1-Spring" class="headerlink" title="3.1 Spring"></a>3.1 Spring</h2><p><strong>Spring框架的单例Bean是线程安全的吗?</strong></p>
<p>Spring框架中的bean是单例的吗?</p>
<p>bean默认是单例的,但是并不是线程安全的</p>
<p>但是像一个controller方法,中注入的service,由于该service是无状态的(就是不能被修改的),那么此时就是线程安全的.</p>
<p><strong>回答</strong><br>不是线程安全的,Spring框架中有一个@Scope注解,默认的值就是singleton,单例的,因为一般在Srping的bean中都是注入无状态的对象,没有线程安全问题,如果在bean中定义了可修改的成员变量,是要考虑线程安全问题的,可以使用多例或者加锁来解决</p>
<hr>
<p><strong>什么是AOP,你们项目中有没有使用到AOP</strong></p>
<p>AOP称为面向切面编程,用于将那些与业务无关,但却对多个对象产生影响的公共行为和逻辑,抽取并封装为一个可重用的模块,这个模块被命名为切面(Aspect),减少系统中的重复代码,降低了模块间的耦合度,同时提高了系统的可维护性</p>
<blockquote>
<p>记录操作日志思路<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/202310171105.jpg" alt="202310171105"><br>获取用户名,请求方式,访问地址,模块名称,登录ip,操作时间,记录到数据库的日志表中</p>
</blockquote>
<p>Spring中的事务是如何实现的</p>
<ol>
<li>编程式事务控制:需使用TransactionTemplate来进行实现,对业务代码有侵入性,项目中很少使用</li>
<li>声明式事务管理:声明式事务管理建立在AOP之上的,其本质是通过AOP功能,对方法前后进行拦截,将事务处理的功能编织到拦截的方法中,也就是在目标方法开始之前加入一个事务,在执行完目标方法之后根据执行情况提交或者回滚事务</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17114051.jpg" alt="2023-10-17114051"></p>
<hr>
<p><strong>Spring事务失效场景</strong></p>
<ol>
<li>情况一:异常捕获处理<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17%2014446.jpg" alt="2023-10-17 14446"><br>原因:事务通知只有捕获到了目标抛出的异常,才能进行后续的回滚处理,如果目标自己处理掉异常,事务通知就无法处理，<strong>所以可以在catch中再次抛出异常就能解决这个问题</strong></li>
<li>情况二:抛出检查异常<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17140911.jpg" alt="2023-10-17140911"><br>原因是,Spring默认只会回滚非检查异常(运行时异常),对于检查异常(编译时异常),如果在方法上抛出的话,这个事务也会失效,解决办法是修改注解 <code>@Transactional(rollbackFor = Exception.class)</code></li>
<li>情况三:非public方法导致的事务失效<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17141426.jpg" alt="2023-10-17141426"><br>原因是:Spring为方法创建代理,添加事务通知,前提条件都是该方法是public</li>
</ol>
<hr>
<p><strong>Spring的bean的生命周期</strong></p>
<p><strong>BeanDefinition</strong><br>Spring容器在进行实例化时,会将xml配置的 <code>&lt;bean&gt;</code>的信息封装成一个BeanDefinition对象,Spring根据BeanDefinition来创建Bean对象,里面有很多的属性来描述Bean<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17144338.jpg" alt="2023-10-17144338"></p>
<ul>
<li>beanClassName: bean的类名</li>
<li>initMethodName: 初始化方法名称</li>
<li>propertyValues: bean的属性值</li>
<li>scope: 作用域</li>
<li>lazyInit: 延迟初始化<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/64644653.jpg" alt="64644653"></li>
</ul>
<p>有了BeanDefinition对象后,就可以进行创建bean了<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/4312431145124.jpg" alt="4312431145124"></p>
<p>回答:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17150052.jpg" alt="2023-10-17150052"></p>
<hr>
<p><strong>Spring中的循环引用</strong></p>
<p>可以是两个类互相引用,也可以是多个<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-17150241.jpg" alt="2023-10-17150241"></p>
<p><strong>循环依赖</strong>:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/-10-1750714.jpg" alt="-10-1750714"></p>
<p>如何解决？</p>
<p>Spring解决循环依赖是通过三级缓存，对应的三级缓存如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Maximum number of suppressed exceptions to preserve. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SUPPRESSED_EXCEPTIONS_LIMIT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line">    <span class="comment">// 一级缓存</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三级缓存</span></span><br><span class="line">	<span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二级缓存</span></span><br><span class="line">	<span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>缓存名称</th>
<th>源码名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>一级缓存</td>
<td>singletonObjects</td>
<td>单例池,缓存已经经历了完整的生命周期,已经初始化完成了bean对象</td>
</tr>
<tr>
<td>二级缓存</td>
<td>earlySingletonObjects</td>
<td>缓存早期的bean对象(生命周期还没走完)</td>
</tr>
<tr>
<td>三级缓存</td>
<td>singletonFactories</td>
<td>缓存的是ObjectFactory,表示对象工厂,用来创建某个对象的</td>
</tr>
</tbody></table>
<p>一级缓存是解决不了循环依赖问题的,它的作用是限制Bean在beanFactory中只存在一份,即实现了singleton scope,解决不了循环依赖,如果想打破循环依赖,就需要一个中间人的参与,也就是二级缓存<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-153536.jpg" alt="2023-10-153536"></p>
<p><strong>可以理解为,创建A时,先把A的半成品放到了二级缓存中,然后A需要注入B,此时开始创建B,B的原始对象也放入一级缓存中,B需要注入A时,直接从二级缓存中取出半成品A,然后B就创建成功了,B的对象就会存入一级缓存中,此时由于B创建成功了,所以此时B也注入到A中,A也创建成功,一样存入一级缓存,再清除二级缓存的半成品</strong></p>
<p>但是此时只能解决一般对象的循环依赖,如果有增强的对象(代理对象),还是不行,就要借助三级缓存</p>
<p>三级缓存的解决方案:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-17215004.jpg" alt="023-10-17215004"></p>
<hr>
<p>当然也有Spring框架无法解决的循环依赖:<strong>构造方法出现了循环依赖</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/fkfldasjll21.jpg" alt="fkfldasjll21"></p>
<p>报错:<code>Is there an unresolvable circular reference</code></p>
<p><strong>解决</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="meta">@Lazy</span> B b)</span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;A的构造方法执行了&quot;</span>);</span><br><span class="line">   <span class="built_in">this</span>.b = b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-SpringMVC"><a href="#3-2-SpringMVC" class="headerlink" title="3.2 SpringMVC"></a>3.2 SpringMVC</h2><h3 id="视图阶段"><a href="#视图阶段" class="headerlink" title="视图阶段"></a>视图阶段</h3><p>核心:DispatcherServlet</p>
<ol>
<li><code>DispatcherServlet</code>接收前端发来的请求.</li>
<li><code>DispatcherServlet</code>查询handler,处理器映射器<code>HandlerMapping</code>返回处理器执行链<code>HandlerExecutionChain</code></li>
<li><code>DispatcherServlet</code>请求执行handler,处理器适配器<code>HandlerAdaptor</code>请求处理器<code>Handler</code>,然后处理器相应给<code>HandlerAdaptor</code></li>
<li>处理器适配器返回ModelAndView给前端控制器</li>
<li><code>DispatcherServlet</code>再将逻辑视图交给视图解析器,由视图解析器将逻辑视图解析为真正的视图,然后返回给<code>DispatcherServlet</code>View对象</li>
<li>视图展示,渲染视图<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-19100158.jpg" alt="2023-10-19100158"></li>
</ol>
<h3 id="前后端分离阶段-接口开发-异步请求"><a href="#前后端分离阶段-接口开发-异步请求" class="headerlink" title="前后端分离阶段(接口开发,异步请求)"></a>前后端分离阶段(接口开发,异步请求)</h3><ol>
<li><code>DispatcherServlet</code>接收前端发来的请求.</li>
<li><code>DispatcherServlet</code>查询handler,处理器映射器<code>HandlerMapping</code>返回处理器执行链<code>HandlerExecutionChain</code></li>
<li><code>DispatcherServlet</code>请求执行handler,处理器适配器<code>HandlerAdaptor</code>请求处理器<code>Handler</code></li>
<li>处理器Handler通过<code>HttpMessageConverter</code>来返回结果转换为JSON并响应<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-19100709.jpg" alt="2023-10-19100709"></li>
</ol>
<h2 id="3-3-SpringBoot"><a href="#3-3-SpringBoot" class="headerlink" title="3.3 SpringBoot"></a>3.3 SpringBoot</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-1901418.jpg" alt="2023-10-1901418"></p>
<ol>
<li><strong>SpringBoot项目中引导类上的@SpringBootApplication注解封装了以下三个注解</strong></li>
</ol>
<ul>
<li><code>@SpringBootConfiguration</code>:该注解与<code>@Configuration</code>注解作用相同,用来声明当前也是一个配置类</li>
<li><code>@ComponentScan</code>:组件扫描,默认扫描当前引导类所在包及其子包</li>
<li><code>@EnableAutoConfiguration</code>:SpringBoot实现自动化配置的核心注解</li>
</ul>
<ol start="2">
<li>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解,该注解通过<code>@Import</code>注解导入对应的配置选择器内部就是读取了该项目和该项目引用的jar包的classpath路径下的<code>META-INF/spring.factories</code>文件中所配置的类的全类名,在这些配置类中所定义的bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中</li>
<li>条件判断会像<code>@ConditionalOnClass</code>这样的注解,判断是否有对应的class文件,如果有则加载该类,把这个配置类的所有的Bean收入spring容器中使用</li>
</ol>
<hr>
<p><strong>常见注解</strong></p>
<ol>
<li>Spring常见注解<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-19105923.jpg" alt="023-10-19105923"></li>
<li>SpringMVC常见注解<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-19110135.jpg" alt="2023-10-19110135"></li>
<li>SpringBoot常见注解<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-10-1910348.jpg" alt="23-10-1910348"></li>
</ol>
<h2 id="3-4-MyBatis"><a href="#3-4-MyBatis" class="headerlink" title="3.4 MyBatis"></a>3.4 MyBatis</h2><p><strong>MyBatis的执行流程</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-19135635.jpg" alt="023-10-19135635"></p>
<ol>
<li>读取MyBatis配置文件:mybatis-config.xml加载运行环境和映射文件</li>
<li>构造会话工厂<code>SqlSessionFactroy</code></li>
<li>会话工厂创建SqlSession对象(包含了执行Sql语句的所有方法)</li>
<li>操作数据库的接口,Executor执行器,同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MapperStatement类型的参数,封装了映射信息</li>
<li>输入参数映射</li>
<li>输出结果映射</li>
</ol>
<hr>
<p><strong>延迟加载</strong></p>
<p>什么叫延迟加载<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/faafdsfsde.jpg" alt="faafdsfsde"></p>
<p>延迟加载的原理</p>
<ol>
<li>使用CGLIB创建目标对象的代理对象</li>
<li>当调用目标方法user.getOrderList()时,进入拦截器invoke方法,发现user.getOrderList()是null值,执行sql查询order列表</li>
<li>把order查询上来,然后调用user.setOrderList()赋值,接着完成user.getOrderList的调用</li>
</ol>
<hr>
<p><strong>一级,二级缓存</strong></p>
<p>一级缓存:基于PerpetualCache的HashMap本地缓存,其存储作用域为Session,当Session进行flush或close之后,该Session中的所有Cache就将清空,默认打开一级缓存<br>二级缓存:基于namespace和mapper的作用域起作用的,不是依赖于sqlsession,默认也是采用PerpetualCache,HashMap存储</p>
<p><strong>注意事项</strong></p>
<ol>
<li>对于缓存数据更新机制,当某个作用域(一级缓存Session&#x2F;二级缓存Namespace)的进行了新增,修改,删除操作后,默认该作用域下所有的select中的缓存将被clear</li>
<li>二级缓存需要缓存的数据实现<code>Serializable</code>接口</li>
<li>只有会话提交或者关闭以后,一级缓存中的数据才会转移到二级缓存中</li>
</ol>
<h1 id="4-集合篇"><a href="#4-集合篇" class="headerlink" title="4 集合篇"></a>4 集合篇</h1><p>Java集合体系<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-20091016.jpg" alt="2023-10-20091016"></p>
<h2 id="4-1-复杂度"><a href="#4-1-复杂度" class="headerlink" title="4.1 复杂度"></a>4.1 复杂度</h2><blockquote>
<p>复杂度表示<code>O</code>表示法,速记口诀:<strong>常对幂指阶</strong></p>
</blockquote>
<p>常见复杂度</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-203333.jpg" alt="023-10-203333"></p>
<p><strong>只要代码的执行时间不随着n的增大而增大,这样的代码复杂度都是O(1)</strong></p>
<p>看下面这个代码<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-20094342.jpg" alt="023-10-20094342"></p>
<p><strong>要明白复杂度分析就是代码的执行次数和数据规模n之间的关系</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-20094453.jpg" alt="023-10-20094453"></p>
<p>所以,这个时间复杂度就是<code>O(log n)</code></p>
<hr>
<p>空间复杂度了解即可</p>
<p>空间复杂度全称是<strong>渐进空间复杂度</strong>,表示算法占用的额外存储空间和数据规模之间的增长关系</p>
<p>一般都是<code>O(1),O(n)</code></p>
<h2 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h2><h3 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h3><p>数组是一种用<strong>连续的内存空间</strong>存储<strong>相同类型数据</strong>的线性数据结构</p>
<p><strong>数组如何获取其他元素的地址值</strong>-寻址公式</p>
<p>寻址公式:<code>a[i] = baseAddress + i*dataTypeSize</code></p>
<ul>
<li><code>baseAddress</code>:数组的首地址</li>
<li><code>dataTypeSize</code>:代表数组中元素类型的大小,int型的数据,占4个字节</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-10-20102747.jpg" alt="23-10-20102747"></p>
<hr>
<p>那为什么数组索引从0开始呢?假如从1开始不行吗</p>
<p>如果从1开始,那么寻址公式还要进行减法,对于CPU来说就多了一条指令,性能降低</p>
<hr>
<p><strong>操作数组的时间复杂度(查找)</strong></p>
<ol>
<li>随机查询(根据索引查询):<code>O(1)</code><br>数组元素的的访问时通过下标来访问的,计算机通过数组的首地址和寻址公式能够很快速的找到想要访问的元素</li>
<li>未知索引查询<ul>
<li>遍历数组<code>O(n)</code></li>
<li>排序后进行二分查找<code>O(logn)</code></li>
</ul>
</li>
</ol>
<p><strong>操作数组的时间复杂度(插入,删除)</strong></p>
<p>数组是一段连续的内存空间,因此为了保证数组的连续性会使得数组的插入和删除的效率变得很低</p>
<p>如果在数组最后插入或删除数据,那么就是<code>O(1)</code>,最坏的情况就是<code>O(n)</code>,也就是在数组中插入,<strong>平均情况下的时间复杂度是<code>O(n)</code></strong></p>
<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><p>先看构造方法,有两个个带参的构造和一个无参构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default initial capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment"> * first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 带初始化容量的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment"> * collection, in the order they are returned by the collection&#x27;s</span></span><br><span class="line"><span class="comment"> * iterator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看第一个有参构造方法,可以发现如果容量不合法(大于等于0)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(-<span class="number">1</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20231020112308.png" alt="20231020112308"><br>而无参构造,默认创建的是空集合,<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code><strong>就是一个空数组</strong></p>
<p>第二个有参构造的作用是:将Collection对象转换成数组,然后将数组的地址赋给<code>elementData</code></p>
<hr>
<p>添加和扩容操作-<strong>第一次添加数据</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-20114851.jpg" alt="2023-10-20114851"></p>
<p>所以在第一次添加数据时,会将容量设为10</p>
<p><strong>第2至第10次添加数据</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/-10-20115432.jpg" alt="-10-20115432"></p>
<p><strong>第11次添加数据-重点</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/3-10-20115958.jpg" alt="3-10-20115958"></p>
<p>总结就是,创建集合时,如果没有指定容量,那么创建时是一个空集合,长度为0,第一次添加数据时,会将容量设为10,再之后添加到第10条数据,都不会发生扩容,当添加第11个数据时,就会发生扩容</p>
<h3 id="ArrayList面试题"><a href="#ArrayList面试题" class="headerlink" title="ArrayList面试题"></a>ArrayList面试题</h3><hr>
<p>ArrayList底层的实现原理:</p>
<ol>
<li>ArrayList底层是用动态数组实现的</li>
<li>ArrayList初始化容量为0,当第一次添加数据时才会初始化容量为10</li>
<li>ArrayList在进行扩容时是原来容量的1.5倍,每次扩容都是拷贝数组</li>
<li>ArrayList在添加数据时<ul>
<li>确保数组已使用长度(size)加1之后足够存下下一个数据</li>
<li>计算数组的容量,如果当前数组已使用长度+1后大于当前数组长度,则调用grow方法扩容(原来的1.5倍)</li>
<li>确保新增的数据有地方存储之后,则将新元素添加到位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ol>
<hr>
<p><code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;(10);</code>中的list扩容了几次<br>该语句只是声明和实例了一个ArrayList,指定了容量为10,未扩容</p>
<hr>
<p><strong>如何实现数组和List之间的转换</strong></p>
<ol>
<li>数组转List,使用<code>Arrays.asList()</code>即可</li>
<li>List转数组,使用List的<code>toArray()</code>,无参方法返回一个<code>Object</code>类型的数组,传入初始化长度的数组对象,返回该对象数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConvert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数组转集合</span></span><br><span class="line">    String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(strArr);</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转数组</span></span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    Integer[] array = list1.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list1.size()]);</span><br><span class="line">    <span class="keyword">for</span> (Integer i : array) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>再问</strong></p>
<ol>
<li>用Arrays.asList转List后,如果修改了数组内容,list受影响吗</li>
<li>List用toArray转数组后,如果修改了List内容,数组受影响吗</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConvert</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 数组转集合</span></span><br><span class="line">    String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(strArr);</span><br><span class="line">    <span class="comment">// list.remove(0);  转换过来的集合是只读的,可以修改单个元素,但是不能添加和删除元素</span></span><br><span class="line">    <span class="comment">// 修改原数组，会发现集合中的数据也发生了变化  ---  数组转集合，是涉及到对象的引用，两个对象指向同一个地址</span></span><br><span class="line">    strArr[<span class="number">0</span>] = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转数组</span></span><br><span class="line">    List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    Integer[] array = list1.toArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[list1.size()]);</span><br><span class="line">    <span class="comment">// 修改原集合 数组不受影响</span></span><br><span class="line">    list1.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 修改数组 集合也不受影响  --   集合转数组，转换之后两者就没关系了,底层是数组的拷贝</span></span><br><span class="line">    array[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer i : list1) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;====&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Integer i : array) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-链表"><a href="#4-3-链表" class="headerlink" title="4.3 链表"></a>4.3 链表</h2><h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p><strong>单向链表</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-10-2072823.jpg" alt="23-10-2072823"></p>
<p><strong>单向链表的查询复杂度</strong></p>
<ol>
<li>只有在查询头节点的时候不需要遍历链表,时间复杂度是<code>O(1)</code></li>
<li>查询其他结点时需要遍历链表,时间复杂度是<code>O(n)</code></li>
</ol>
<p><strong>插入&#x2F;删除复杂度</strong></p>
<ol>
<li>只有在添加和删除头节点时不需要遍历链表,时间复杂度是<code>O(1)</code></li>
<li>添加或删除其他节点需要遍历链表找到对应节点后,才能完成新增或删除节点,时间复杂度是<code>O(n)</code></li>
</ol>
<hr>
<p><strong>双向链表</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-10-20173741.jpg" alt="23-10-20173741"></p>
<ul>
<li>每个节点不止有一个后继指针next指向后面的结点</li>
<li>有一个前去指针prev指向前面的结点</li>
</ul>
<p>对比单链表的区别</p>
<ul>
<li>双向链表需要额外的一个空间来存储前驱结点的地址</li>
<li>支持双向遍历,这样也带来了双向链表的灵活性</li>
</ul>
<p>双向链表的复杂度分析</p>
<ol>
<li>查询复杂度<ul>
<li>查询头尾结点的时间复杂度是<code>O(1)</code></li>
<li>平均的查询时间复杂度是<code>O(n)</code></li>
<li>给定节点找前驱结点的时间复杂度<code>O(1)</code></li>
</ul>
</li>
<li>增删操作<ul>
<li>头尾结点增删的时间复杂度为<code>O(1)</code></li>
<li>其他部分结点增删的时间复杂度是<code>O(n)</code></li>
<li>给定结点增删的时间复杂度为<code>O(1)</code></li>
</ul>
</li>
</ol>
<hr>
<p><strong>ArrayList与LinkedList的区别是什么</strong></p>
<ol>
<li>底层数据结构<ul>
<li>ArrayList底层是动态数组</li>
<li>LinkedList是双向链表</li>
</ul>
</li>
<li>操作数据的效率<ul>
<li>ArrayList按照下标查询的时间复杂度是<code>O(1)</code>,而LinkedList不能这么查询</li>
<li>未知索引查询,两个都需要遍历,都是<code>O(n)</code></li>
<li>新增和删除<ul>
<li>ArrayList尾部插入和删除,时间复杂度是<code>O(1)</code>,其他部分增删需要挪动数组,时间复杂度是<code>O(n)</code></li>
<li>LinkedList头尾节点增删时间复杂度是<code>O(1)</code>,其他都需要遍历链表,时间复杂度是<code>O(n)</code></li>
</ul>
</li>
</ul>
</li>
<li>内存空间占用<ul>
<li>ArrayList底层是数组,内存连续,节省内存</li>
<li>LinkedList是双向链表需要存储数据,和两个指针,更占用内存</li>
</ul>
</li>
<li>线程安全<ul>
<li>都不是线程安全的</li>
</ul>
</li>
</ol>
<p>那既然两个都不是线程安全的,那如何保证线程安全?</p>
<ul>
<li>在方法内使用,局部变量则是线程安全的</li>
<li>使用<code>List&lt;Integer&gt; synchronizedList = Collections.synchronizedList(new ArrayList&lt;&gt;());</code>来包装成一个线程安全的集合</li>
</ul>
<h2 id="4-4-二叉树"><a href="#4-4-二叉树" class="headerlink" title="4.4 二叉树"></a>4.4 二叉树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树(BST)又名二叉查找树,有序二叉树或者排序二叉树,是二叉树中比较常用的一种类型,二叉查找树要求,在树种的任意一个节点,其左子树中的每个结点的值,都要小于这个节点的值,而右子树结点的值都大于这个节点的值</p>
<p>二叉搜索树<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-2082832.jpg" alt="023-10-2082832"></p>
<p>查找,插入,删除的时间复杂度都是<code>O(logn)</code></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>自平衡的二叉搜索树</p>
<p><strong>特性如下:</strong></p>
<ol>
<li>节点要么是红色,要么是黑色</li>
<li>根节点是黑色</li>
<li>叶子节点都是黑色的空节点</li>
<li>红黑树中红色节点的子节点都是黑色</li>
<li>从任一同深度节点到叶子节点的所有路径都包含相同数目的黑色节点<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-2083833.jpg" alt="2023-10-2083833"></li>
</ol>
<p><strong>在添加或删除节点时,如果不符合这些性质则会发生旋转,以达到所有的性质,来保证平衡</strong></p>
<hr>
<p>红黑树的复杂度</p>
<ul>
<li>查找<br>红黑树也是一棵BST(二叉搜索树)树,查找操作的时间复杂度为<code>O(logn)</code></li>
<li>添加<br>添加先要从根节点开始找到元素添加的位置,时间复杂度为<code>O(logn)</code>,添加完成后涉及到复杂度为<code>O(1)</code>的旋转调整操作,故整体复杂度为<code>O(logn)</code></li>
<li>删除<br>首先从根节点开始找到被删除元素的位置,时间复杂度为<code>O(logn)</code>,删除完成后涉及到复杂度为<code>O(1)</code>的旋转调整操作,故整体复杂度为<code>O(logn)</code></li>
</ul>
<h2 id="4-4-散列表"><a href="#4-4-散列表" class="headerlink" title="4.4 散列表"></a>4.4 散列表</h2><p>在HashMap中最重要的一个数据结构就是散列表,在散列表中又使用到了红黑树和链表</p>
<p>散列表(HashTable)又名为<strong>哈希表</strong>&#x2F;Hash表,是根据键(Key)直接访问在内存存储位置值(Value)的数据结构,它是由数组演化而来的,利用了数组支持按照下标进行随机访问数据的特性</p>
<p>将键(Key)映射为数组下标的函数叫做散列函数,可以表示为<code>hashValue = hash(key)</code></p>
<p>散列函数的基本要求</p>
<ol>
<li>散列函数计算得到的散列值必须是大于等于0的正整数,因为hashValue需要作为数组的下标</li>
<li>如果key1&#x3D;&#x3D;key2,那么经过hash后得到的哈希值也比相同<code>hash(key1) == hash(key2)</code></li>
<li>如果key1!&#x3D;key2,那么经过hash后得到的哈希值也必不相同即:<code>hash(key1)!=hash(key2)</code></li>
</ol>
<hr>
<p><strong>散列冲突</strong><br>实际的情况下想找一个散列函数能够做到对于不同的key计算得到的散列值不同<strong>几乎是不可能的</strong>,即便像著名的MD5,SHA等哈希算法也无法避免这一情况,这就是<strong>散列冲突</strong>(或者哈希冲突,哈希碰撞,就是指多个key映射到同一个数组下标位置)</p>
<p>要解决散列冲突,有以下方法</p>
<h2 id="4-5-链表法"><a href="#4-5-链表法" class="headerlink" title="4.5 链表法"></a>4.5 链表法</h2><p>链表法(拉链)解决散列冲突</p>
<p>在散列表中,数组的每个下标位置我们可以称之为<strong>桶(bucket)或者槽(slot)</strong>,每个桶会对应一条链表,所有散列值相同的元素我们都放到相同槽位对应的链表中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/23-10-2011816.jpg" alt="23-10-2011816"></p>
<p>插入操作时,通过散列函数计算得到对应的散列槽位,将其插入对应链表中即可,插入的时间复杂度为<code>O(1)</code></p>
<p>查找,删除一个元素时,我们同样通过散列函数计算出对应的槽,然后遍历链表查找或者删除</p>
<ul>
<li>平均情况下基于链表法解决冲突时查询的时间复杂度是<code>O(1)</code></li>
<li>散列表可能会退化为链表,查询的时间复杂度就从O(1)退化为O(n)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-20212737.jpg" alt="023-10-20212737"></li>
<li>将链表法中的链表改造为其他高效的动态数据结构,比如红黑树,查询的时间复杂度是<code>O(logn)</code></li>
</ul>
<h2 id="4-6-HashMap面试题"><a href="#4-6-HashMap面试题" class="headerlink" title="4.6 HashMap面试题"></a>4.6 HashMap面试题</h2><p><strong>HashMap的实现原理</strong><br>HashMap的数据结构:底层使用<strong>hash表数据结构,即数组和链表或红黑树</strong></p>
<ol>
<li>当我们往HashMap中put元素时,利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</li>
<li>存储时,如果出现hash值相同的key,此时有两种情况<ul>
<li>如果key相同,则覆盖原始值</li>
<li>如果key不同(出现冲突),则将当前key-value放入链表或红黑树</li>
</ul>
</li>
<li>获取时,直接找到hash值对应的下标,在进一步判断key是否相同,从而找到对应值<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-20214201.jpg" alt="2023-10-20214201"></li>
</ol>
<p><strong>链表的长度大于8且数组长度大于等于64,转换为红黑树</strong></p>
<hr>
<p><strong>HashMap的jdk1.7和jdk1.8有什么区别</strong></p>
<ul>
<li>JDK1.8之前采用的是拉链法,将链表和数组相结合,也就是说创建一个链表数组,数组中每一格就是一个链表,若遇到哈希冲突,则将冲突的值加到链表中即可</li>
<li>JDK1.8在解决哈希冲突时,当链表长度大于阈值(8)时并且数组长度到达64,将链表转化为红黑树,以减少搜索时间,扩容resize()时,红黑树拆分成的树的结点数小于等于临界值6个,则退化成链表</li>
</ul>
<hr>
<p><strong>HashMap的put方法的具体流程</strong></p>
<p>初始化一个HashMap</p>
<ul>
<li>HashMap是懒惰加载,在创建对象时并没有初始化数组</li>
<li>在无参的构造方法中,设置了默认的加载因子为0.75f</li>
</ul>
<p>看看源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个HashMap</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zzmr&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment">  * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而这个DEFAULT_LOAD_FACTOR 就是上面声明的加载因子</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>添加的具体流程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-2090844.jpg" alt="2023-10-2090844"></p>
<ol>
<li>判断键值对数组table是否为空或者null,否则执行resize()进行扩容(初始化)</li>
<li>根据键值key计算hash值得到数组索引</li>
<li>判断<code>table[i]==null</code>,条件成立,直接新建节点添加</li>
<li>如果<code>table[i]==null</code>不成立<ul>
<li>判断<code>table[i]</code>的首个元素是否和key一样,如果相同则直接覆盖value</li>
<li>判断<code>table[i]</code>是否为treeNode,即<code>table[i]</code>是否是红黑树,如果是红黑树,则直接在树中插入键值对</li>
<li>遍历<code>table[i]</code>,链表的尾部插入数据,然后判断链表长度是否大于8,大于8的话把链表转换为红黑树,在红黑树中执行插入操作,遍历过程中若发现key已存在则直接覆盖value</li>
</ul>
</li>
<li>插入成功后,判断实际存在的键值对数量size是否超过了最大容量<code>threshold</code>(数组长度*0.75),如果超过,进行扩容</li>
</ol>
<hr>
<p>扩容的具体流程<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-10-21095051.jpg" alt="2023-10-21095051"></p>
<ol>
<li>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16,以后每个每次扩容都是达到了扩容阈值(数组长度*0.75)</li>
<li>每次扩容的时候,都是扩容之前容量的2倍</li>
<li>扩容之后,会新创建一个数组,需要把老数组中的数据挪动到新的数组中<ul>
<li>没有hash冲突的节点,则直接使用<code>e.hash &amp; (newCap -1)</code>计算新数组的索引位置</li>
<li>如果是红黑树,走红黑树的添加</li>
<li>如果是链表,则需要遍历链表,可能需要拆分链表,判断<code>(e.hash &amp; oldCap)</code>是否为0,该元素的位置要么停留在原始位置,要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ol>
<h3 id="put源码"><a href="#put源码" class="headerlink" title="put源码"></a>put源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断数组是否未初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果未初始化，调用resize方法 进行初始化</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//通过 &amp; 运算求出该数据（key）的数组下标并判断该下标位置是否有数据</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果没有，直接将数据放在该下标位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//该数组下标有数据的情况</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断该位置数据的key和新来的数据是否一样</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//如果一样，证明为修改操作，该节点的数据赋值给e,后边会用到</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//判断是不是红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//如果是红黑树的话，进行红黑树的操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//新数据和当前数组既不相同，也不是红黑树节点，证明是链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//判断next节点，如果为空的话，证明遍历到链表尾部了</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//把新值放入链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">//因为新插入了一条数据，所以判断链表长度是不是大于等于8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//如果是，进行转换红黑树操作</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断链表当中有数据相同的值，如果一样，证明为修改操作</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//把下一个节点赋值为当前节点</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断e是否为空（e值为修改操作存放原数据的变量）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//不为空的话证明是修改操作，取出老值</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//一定会执行  onlyIfAbsent传进来的是false</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将新值赋值当前节点</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回老值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计数器，计算当前节点的修改次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//当前数组中的数据数量如果大于扩容阈值</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        <span class="comment">//进行扩容操作</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//空方法</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="comment">//添加操作时 返回空值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩容源码"><a href="#扩容源码" class="headerlink" title="扩容源码"></a>扩容源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容、初始化数组</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    	<span class="comment">//如果当前数组为null的时候，把oldCap老数组容量设置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="comment">//老的扩容阈值</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断数组容量是否大于0，大于0说明数组已经初始化</span></span><br><span class="line">    	<span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前数组长度是否大于最大数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//如果是，将扩容阈值直接设置为int类型的最大数值并直接返回</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在最大长度范围内，则需要扩容  OldCap &lt;&lt; 1等价于oldCap*2</span></span><br><span class="line">            <span class="comment">//运算过后判断是不是最大值并且oldCap需要大于16</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  等价于oldThr*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果oldCap&lt;0，但是已经初始化了，像把元素删除完之后的情况，那么它的临界值肯定还存在，       			如果是首次初始化，它的临界值则为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//数组未初始化的情况，将阈值和扩容因子都设置为默认值</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//初始化容量小于16的时候，扩容阈值是没有赋值的</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//创建阈值</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//判断新容量和新阈值是否大于最大容量</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//计算出来的阈值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        <span class="comment">//根据上边计算得出的容量 创建新的数组       </span></span><br><span class="line">    	Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    	<span class="comment">//赋值</span></span><br><span class="line">    	table = newTab;</span><br><span class="line">    	<span class="comment">//扩容操作，判断不为空证明不是初始化数组</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//判断当前下标为j的数组如果不为空的话赋值个e，进行下一步操作</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//将数组位置置空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">//判断是否有下个节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果没有，就重新计算在新数组中的下标并放进去</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   	<span class="comment">//有下个节点的情况，并且判断是否已经树化</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//进行红黑树的操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//有下个节点的情况，并且没有树化（链表形式）</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//比如老数组容量是16，那下标就为0-15</span></span><br><span class="line">                        <span class="comment">//扩容操作*2，容量就变为32，下标为0-31</span></span><br><span class="line">                        <span class="comment">//低位：0-15，高位16-31</span></span><br><span class="line">                        <span class="comment">//定义了四个变量</span></span><br><span class="line">                        <span class="comment">//        低位头          低位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//        高位头		   高位尾</span></span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">//下个节点</span></span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="comment">//循环遍历</span></span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//取出next节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果为0</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果低位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入低位头</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="comment">//低位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//记录低位尾数据</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//通过 与操作 计算得出结果不为0</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//如果高位尾为null，证明当前数组位置为空，没有任何数据</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//将e值放入高位头</span></span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="comment">//高位尾不为null，证明已经有数据了</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将数据放入next节点</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                               <span class="comment">//记录高位尾数据</span></span><br><span class="line">                               	hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; </span><br><span class="line">                        <span class="comment">//如果e不为空，证明没有到链表尾部，继续执行循环</span></span><br><span class="line">                        <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//低位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将低位头放入新数组的原下标位置</span></span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位尾如果记录的有数据，是链表</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//将下一个元素置空</span></span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            <span class="comment">//将高位头放入新数组的(原下标+原数组容量)位置</span></span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回新的数组对象</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="get源码"><a href="#get源码" class="headerlink" title="get源码"></a>get源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//hash(key)，获取key的hash值</span></span><br><span class="line">    <span class="comment">//调用getNode方法，见下面方法</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">//找到key对应的桶下标，赋值给first节点</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断hash值和key是否相等，如果是，则直接返回，桶中只有一个数据（大部分的情况）</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//该节点是红黑树，则需要通过红黑树查找数据</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//链表的情况，则需要遍历链表查找数据</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h3><p><strong>HashMap的寻址算法</strong></p>
<ol>
<li>计算对象的hashCode()</li>
<li>再进行调用hash()方法进行二次哈希,hashcode值右移16位再异或运算,让哈希分布更为均匀</li>
<li>最后<code>(capacity - 1)&amp;hash</code>得到索引(capacity是数组长度)</li>
</ol>
<p><strong>为何hashMap的数组长度一定是2的次幂</strong></p>
<ol>
<li>计算索引时效率更高,如果是2的n次幂可以使用位运算代替取模</li>
<li>扩容时重新计算索引效率更高:<code>hash&amp;odlCap == 0</code>的元素留在原来位置,否则新位置&#x3D;旧位置+oldCap</li>
</ol>
<h1 id="5-并发编程篇"><a href="#5-并发编程篇" class="headerlink" title="5 并发编程篇"></a>5 并发编程篇</h1><h2 id="5-1-线程的基础知识"><a href="#5-1-线程的基础知识" class="headerlink" title="5.1 线程的基础知识"></a>5.1 线程的基础知识</h2><p><strong>线程和进程的区别</strong></p>
<ol>
<li>进程是正在运行程序的实例,进程中包含了线程,每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间,在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量,线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)</li>
</ol>
<hr>
<p><strong>并行和并发有什么区别</strong></p>
<p>并发,同一时间段内做多件事情-一个CPU轮流执行多个线程<br>并行,同一时刻做多件事情-4核CPU同时执行4个线程</p>
<hr>
<p><strong>创建线程的方式有哪些</strong></p>
<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口</li>
<li>线程池创建线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继承Thread类</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现Runnable接口</span></span><br><span class="line">        <span class="type">MyThread1</span> <span class="variable">myThread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread1);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现Callable接口</span></span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        FutureTask&lt;String&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(myCallable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ct2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">        ct1.start();</span><br><span class="line">        ct2.start();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> ft.get();</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        threadPool.submit(<span class="keyword">new</span> <span class="title class_">MyThread1</span>());</span><br><span class="line"></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyThread1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Callable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>runnable和callable有什么区别</strong></p>
<ol>
<li>Runnable接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，是个泛型，和Future，FutureTask配合可以用来获取异步执行的结果</li>
<li>Callable接口的call方法允许抛出异常,而Runnable接口的run方法的异常只能在内部消化,不能继续上抛</li>
</ol>
<hr>
<p><strong>线程包括哪些状态,状态之间是如何变化的</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20230921221849.png" alt="20230921221849"></p>
<hr>
<p><strong>新建t1,t2,t3三个线程,如何保证它们按顺序执行</strong></p>
<p>使用join,t2中调用<code>t1.join()</code>,然后t3中调用<code>t2.join()</code></p>
<hr>
<p><strong>notify和notifyAll有什么区别</strong></p>
<ul>
<li>wait():线程一旦执行此方法,就进入等待状态,同时,会释放对同步监视器的调用</li>
<li>notify()一旦执行,就会唤醒被wait()的线程中优先级最高的那个,如果多个线程的优先级相同,则随机唤醒一个,被唤醒的线程从wait的位置继续执行</li>
<li>notifyAll(),一旦执行此方法,就会唤醒所有被wait的方法</li>
</ul>
<hr>
<p>wait和sleep方法有什么区别</p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/c2ca7a91.html#%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6">参考这里</a></p>
<p><strong>共同点</strong></p>
<p>wait,sleep的效果都是让当前线程暂时放弃CPU的使用权,进入阻塞状态</p>
<p><strong>不同点</strong></p>
<ol>
<li>方法归属不同<ul>
<li>sleep是Thread的静态方法</li>
<li>wait是Object的成员方法,每个对象都有</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行sleep和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait可以被notify唤醒</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>锁特征不同(重点)<ul>
<li>wait方法的调用必须先获取wait对象的锁,而sleep则无此限制</li>
<li>wait方法执行后会释放对象锁,允许其他线程获得该对象锁</li>
<li>sleep如果在synchronized代码块中执行,并不会释放对象锁</li>
</ul>
</li>
</ol>
<hr>
<p><strong>如何停止一个正在运行的线程</strong></p>
<ol>
<li>使用退出标志,使线程正常退出,也就是run方法完成后线程停止<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread...run...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">        myThread.flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用stop方法强行停止(不推荐,已废弃)</li>
<li>使用interrupt方法中断线程<ul>
<li>打断阻塞的线程(sleep,wait,join)的线程,线程会抛出<code>InterruptedException</code></li>
<li>打断正常的线程,可以根据打断状态来标记是否退出线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打断阻塞的线程</span></span><br><span class="line">        <span class="comment">/*Thread t1 = new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">            System.out.println(&quot;t1正在运行&quot;);</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                Thread.sleep(5000);</span></span><br><span class="line"><span class="comment">            &#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">                e.printStackTrace();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;, &quot;t1&quot;);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        Thread.sleep(500);</span></span><br><span class="line"><span class="comment">        t1.interrupt();</span></span><br><span class="line"><span class="comment">        System.out.println(t1.isInterrupted());*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打断正常的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;打断状态&quot;</span> + interrupted);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        t2.interrupt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="5-2-线程中并发安全"><a href="#5-2-线程中并发安全" class="headerlink" title="5.2 线程中并发安全"></a>5.2 线程中并发安全</h2><p><strong>synchronized关键字的底层原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/c2ca7a91.html#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97">用法参考这里</a></p>
<p><code>synchronized</code>采用互斥的方法让同一时刻至多只有一个线程能持有<code>对象锁</code>,其他线程再想获取这个<code>对象锁</code>时就会阻塞住</p>
<p><strong>底层原理-Monitor</strong>,监视器,由JVM提供,C++语言实现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-10-2712324.jpg" alt="023-10-2712324"></p>
<hr>
<p><code>synchronized</code><strong>关键字的底层原理-进阶</strong></p>
<p>Monitor实现的锁属于重量级锁,你了解过锁升级吗?</p>
<ul>
<li><code>Monitor</code>实现的锁属于重量级锁,里面涉及到了用户态和内核态的切换,进程的上下文切换,进程的上下文切换成本较高,性能比较低</li>
<li>在JDK1.6引入了两种新型锁机制:<strong>偏向锁和轻量级锁</strong>,它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题</li>
</ul>
<p><strong>Monitor重量级锁</strong><br>每个Java对象都可以关联一个Monitor对象,如果使用<code>synchronized</code>给对象上锁(重量级)之后,该对象头的Mark Word中就被设置指向Monitor对象的指针</p>
<p><strong>轻量级锁</strong><br>在很多情况下,同步代码块中的代码都是不存在竞争的,不同的线程交替的执行同步块中的代码,这种情况下,用重量级锁是没必要的,因此JVM引入了轻量级锁的概念</p>
<p><strong>偏向锁</strong><br>轻量级锁在没有竞争时(就自己一个线程),每次冲入仍然需要执行CAS操作,Java6中引入了偏向锁来做进一步优化,只有第一次使用CAS将线程ID设置到对象的MarkWord头,之后发现这个线程id是自己的就表示没有竞争,不用重新CAS,以后只要不发生竞争,这个对象就归线程所有</p>
<p>接上面的问题:<em>Monitor实现的锁属于重量级锁,你了解过锁升级吗?</em><br>Java中的synchronized有偏向锁,轻量级锁,重量级锁三种形式,分别对应了锁只被一个线程持有,不同线程交替持有锁,多线程竞争锁三种情况</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>重量级锁</td>
<td>底层使用Monitor实现,里面涉及到了用户态和内核态的切换,进程的上下文切换,成本较高,性能比价低</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>线程加锁的时间是错开的(也就是没有竞争),可以使用轻量级锁来优化,轻量级修改了对象头的锁标志,相对重量级锁性能提升很多,每次修改都是CAS操作,保证原子性</td>
</tr>
<tr>
<td>偏向锁</td>
<td>一段很长的时间都只被一个线程使用锁,可以使用偏向锁,在第一次获得锁时,会有一个CAS操作,之后该线程再获取锁,只需要判断<code>markword</code>中是否是自己的线程id即可,而不是开销相对较大的CAS命令</td>
</tr>
</tbody></table>
<p><strong>一旦锁发生了竞争,都会升级为重量级锁</strong></p>
<h3 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h3><p>JMM(Java内存模型)</p>
<ul>
<li>定义了<strong>共享内存</strong>中<strong>多线程程序读写操作</strong>的行为规范,通过这些规则里规范对内存的读写操作从而保证指令的正确性</li>
<li>JMM把内存分为两块,一块是私有线程的工作区域(工作内存),一块是所有线程的共享内存</li>
<li>线程跟线程之间是相互隔离,线程跟线程交互需要通过主内存</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1155226.jpg" alt="2023-11-1155226"> </p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS(Compare Anderson Swap)比较再交换,它体现的是一种乐观锁的思想,在无锁情况下保证线程操作共享数据的原子性</p>
<p>涉及到<strong>自旋</strong></p>
<p>一个线程拿到了一个共享数据a,想修改a,修改完a之后,想把修改后的a同步到主内存中,那么这时会<strong>先拿原来的a值与共享内存中的a进行对比,如果相同(表示a并没有被修改),此时进行更新操作</strong></p>
<p>而自旋,就是重新发现数据被修改后,重新获取新的数据,进行重复的修改操作.</p>
<p>优势</p>
<ul>
<li>没有加锁,所以线程不会陷入阻塞,效率较高</li>
<li>如果竞争激烈,重试频繁繁盛,效率会受影响</li>
</ul>
<blockquote>
<p>CAS底层<br>CAS底层依赖于一个Unsafe类来直接调用操作系统底层的CAS指令</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>乐观锁和悲观锁</p>
<ul>
<li>CAS是基于乐观锁的思想:最乐观的估计,不怕别的线程来修改共享变量,就算改了也没关系,重试就行</li>
<li><code>synchronized</code>是基于悲观锁的思想:最悲观的估计,得防着其他线程来修改共享变量</li>
</ul>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>一旦一个共享变量(类的成员变量,类得静态成员变量)被volatile修饰之后,那么就具备了两层雨衣</p>
<ul>
<li>保证线程间得可见性<br>用volatile修饰得共享变量,能够防止编译器等优化发生,让一个线程对共享变量得修改对另一个线程可见<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-113645.png" alt="2023-11-113645"></li>
<li>禁止进行指令重排序<br>用volatile修饰得共享变量会在读,写共享变量时加入不同得屏障,阻止其他读写操作越过屏障,从而达到阻止重排序得效果</li>
</ul>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>全称<code>Abstract Queued Synchronizer</code>,即抽象队列同步器,它是构建锁或者其他同步组件得<strong>基础框架</strong></p>
<p>AQS与<code>Synchronized</code>的区别</p>
<table>
<thead>
<tr>
<th>synchronized</th>
<th>AQS</th>
</tr>
</thead>
<tbody><tr>
<td>关键字,c++语言实现</td>
<td>java语言实现</td>
</tr>
<tr>
<td>悲观锁,自动释放锁</td>
<td>悲观锁,手动开启和关闭</td>
</tr>
<tr>
<td>锁竞争激烈都是重量级锁,性能差</td>
<td>锁竞争激烈的情况下,提供了多种解决方案</td>
</tr>
</tbody></table>
<ul>
<li>AQS内部维护了一个先进先出的双向队列,队列中存储的排队的线程</li>
<li>在AQS内部还有一个属性state,这个state就相当于是一个资源,默认是0,如果队列中有一个线程修改成功了state为1,则当前线程就相当于获取了资源</li>
<li>在对state修改的时候使用cas操作,保证多个线程修改的情况下的原子性</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-11165809.jpg" alt="2023-11-11165809"></p>
<h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3><p><code>ReentrantLock</code>可重入锁,相对于<code>synchronized</code>具备以下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁</li>
<li>支持多个条件变量</li>
<li>与<code>synchronized</code>一样,都支持重入</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建锁对象</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 获取锁</span></span><br><span class="line">   lock.lock(); </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ReentrantLock</code>主要利用CAS+AQS来实现,它支持公平锁和非公平锁,两者的实现类似<br>构造方法接受一个可选的公平参数(默认非公平锁),当设置为true时,表示公平锁,否则为非公平锁,公平锁的效率没有非公平锁的效率高,在许多线程访问的情况下,公平锁表现出较低的吞吐量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-11170707.jpg" alt="2023-11-11170707"></p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p><code>synchronized</code>与lock的区别</p>
<ul>
<li>语法层面<br><code>synchronized</code>是关键字,源码在jvm中,用c++实现的<br>Lock是接口,源码由jdk提供,用java语言实现<br>使用<code>synchronized</code>时,退出同步代码块锁会自动释放,而使用Lock时,需要手动调用unlock方法释放锁</li>
<li>功能层面<br>二者均属于悲观锁,都具备基本的互斥,同步,锁重入功能<br>Lock提供了许多<code>synchronized</code>不具备的功能,例如公平锁,可打断,可超市,多条件变量<br>Lock有适合不同场景的实现,如<code>ReentrantLock,ReentrantReadWriteLock(读写锁)</code></li>
<li>性能层面<br>在没有竞争时,<code>synchronized</code>做了很多优化,如偏向锁,轻量级锁,性能很好<br>在竞争激烈时,Lock的实现通常会提供更好的性能</li>
</ul>
<h3 id="死锁产生条件"><a href="#死锁产生条件" class="headerlink" title="死锁产生条件"></a>死锁产生条件</h3><p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/c2ca7a91.html#%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">相关文章</a></p>
<p>很简单例子就是:线程1持有A的锁等待获取B锁,线程2持有B锁等待获取A锁</p>
<p>当程序出现了死锁,我们可以使用JDK自带的工具,jps和jstack</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-12093442.jpg" alt="2023-11-12093442"></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>出现频率很高</strong></p>
<p><code>ConcurrentHashMap</code>是一种线程安全的高效Map集合</p>
<p>底层数据结构</p>
<ul>
<li>JDK1.7底层采用分段的数组+链表实现</li>
<li>JDK1.8采用的数据结构跟HashMap1.8的结构一样,数组+链表&#x2F;红黑树</li>
</ul>
<p>采用CAS+<code>Synchronized</code>来保证并发安全进行实现</p>
<ul>
<li>CAS控制数组节点的添加</li>
<li><code>synchronized</code>只锁定当前链表或红黑二叉树的首节点,只要hash不冲突,就不会产生并发的问题,效率得到提升</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1294632.jpg" alt="2023-11-1294632"></p>
<h3 id="导致并发程序出现问题的根本原因是什么"><a href="#导致并发程序出现问题的根本原因是什么" class="headerlink" title="导致并发程序出现问题的根本原因是什么"></a>导致并发程序出现问题的根本原因是什么</h3><p>(Java程序中怎么保证多线程的执行安全)</p>
<p>Java并发编程三大特征</p>
<ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h2 id="5-3-线程池"><a href="#5-3-线程池" class="headerlink" title="5.3 线程池"></a>5.3 线程池</h2><h3 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h3><p><em>线程池的执行原理</em></p>
<p>线程池类的一个构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>corePoolSize</code>核心线程数目</li>
<li><code>maximumPoolSize</code>最大线程数目&#x3D;(核心线程+就急线程的最大数目)</li>
<li><code>keepAliveTime</code>生存时间-救急线程的生存时间,生存时间内没有新任务,此线程资源会释放</li>
<li><code>unit</code>时间单位-救急线程的生存时间的单位,如秒,毫秒等</li>
<li><code>workQueue</code>当没有空闲核心线程时,新来任务会加入到此队列排队,队列满时会创建救急线程执行任务</li>
<li><code>threadFactory</code>线程工厂-可以定制线程对象的创建,例如设置线程名字,是否是守护线程等</li>
<li><code>handler</code>拒绝策略-当所有线程都在忙时,<code>workQueue</code>也放满时,会触发决绝策略</li>
</ul>
<hr>
<blockquote>
<p>线程池的执行原理<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1201038.jpg" alt="2023-11-1201038"></p>
</blockquote>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><code>workQueue</code>-当没有空闲核心线程时,新来任务会加入到此队列排队,队列满时会创建救急线程执行任务</p>
<ul>
<li><code>ArrayBlockingQueue</code>:基于数组结构的有界阻塞队列,FIFO</li>
<li><code>LinkedBlockingQueue</code>:基于链表结构的有界阻塞队列,FIFO</li>
<li><code>DelayedWorkQueue</code>:是一个优先级队列,它可以保证每次出队的任务都是当前队列中执行时间最靠前的</li>
<li><code>SynchronousQueue</code>:不存储元素的阻塞队列,每个插入操作都必须等待一个移出操作</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1201656.jpg" alt="2023-11-1201656"></p>
<h3 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h3><ul>
<li>IO密集型任务<br>一般来说,文件读写,DB读写,网络请求等:<strong>核心线程数大小设置为<code>2N+1</code></strong></li>
<li>CPU密集型任务<br>一般来说,计算型代码,Bitmap转换,Gson转换等:<strong>核心线程数大小设置为N+1</strong></li>
</ul>
<p><em>查看CPU的逻辑处理器数量</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProcessors</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h3><ol>
<li>创建使用固定线程数的线程池<ul>
<li>核心线程数与最大线程数一样,没有救急线程</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>,最大容量为<code>Integer.MAX_VALUE</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>单线程化的线程池,它只会用唯一的工作线程来执行任务,保证所有任务<strong>按照指定顺序(FIFO)执行</strong><ul>
<li>核心线程数和最大线程数都是1</li>
<li>阻塞队列是<code>LinkedBlockingQueue</code>,最大容量为<code>Integer.MAX_VALUE</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>可缓存线程池(适合任务数比较密集,但是每个任务执行时间较短的情况)<ul>
<li>核心线程数为0</li>
<li>最大线程数是<code>Integer.MAX_VALUE</code></li>
<li>阻塞队列为<code>SynchronousQueue</code>:不存储元素的阻塞队列,每个插入操作都必须等待一个移出操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>提供了延迟和周期执行功能的<code>ThreadPoolExecutor</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-12104552.jpg" alt="2023-11-12104552"></li>
</ol>
<p><strong>总结</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-11-124813.jpg" alt="023-11-124813"></p>
<hr>
<p><strong>为什么不建议用Executors创建线程池</strong></p>
<p>阿里开发者手册-嵩山版<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-12104946.jpg" alt="2023-11-12104946"></p>
<h2 id="5-4-使用场景"><a href="#5-4-使用场景" class="headerlink" title="5.4 使用场景"></a>5.4 使用场景</h2><p><code>CountDownLatch</code>,闭锁,倒计时锁,用来进行线程同步协作,等待所有线程完成倒计时(一个或者多个线程,等待其他多个线程完成某件事情之后才能执行)</p>
<ul>
<li>其中构造参数用来初始化等待计数值</li>
<li>await()用来等待计数归零</li>
<li>countDown()用来让计数减一</li>
</ul>
<p>在一个电商网站中,用户下单之后,需要查询数据,数据包含了三部分,订单信息,包含的商品,物流信息,这三块信息都在不同的微服务中进行实现的,我们如何完成这个业务呢<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/023-11-1210717.jpg" alt="023-11-1210717"></p>
<p>还有一个就是<strong>异步调用</strong></p>
<p>为了避免下一级方法影响上一级方法(性能考虑),可以使用异步线程调用下一个方法(不需要下一级方法返回值),可以提升响应速度</p>
<hr>
<p>如何控制某个方法允许并发访问线程的数量</p>
<p><code>Semaphore</code>信号量,是JUC包下的一个工具类,底层是AQS,我们可以通过其限制执行的线程数量</p>
<p>使用场景:通常用于哪些资源有明确访问数量限制的场景,常用于限流</p>
<h2 id="5-5-ThreadLocal"><a href="#5-5-ThreadLocal" class="headerlink" title="5.5 ThreadLocal"></a>5.5 ThreadLocal</h2><p>ThreadLocal是多线程中对于解决线程安全的一个操作类,它会为<strong>每个线程都分配以个独立的线程副本</strong>,从而解决了变量并发访问冲突的问题,ThreadLocal同时实现了线程内的资源共享</p>
<p>(可以参考苍穹外卖项目中的ThreadLocal用法)</p>
<hr>
<p>ThreadLocal本质来说就是一个线程内部存储类,从而让多个线程只从左自己内部的值,从而实现线程数据隔离</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>ThreadLocal中的内存泄漏问题<br>Java对象的四种引用类型,强引用,软引用,弱引用,虚引用</p>
</blockquote>
<ul>
<li>强引用:最普通的引用方式,表示一个对象处于<strong>有用且必须</strong>的装填,如果一个对象具有强引用,则GC并不会回收它,即便堆中内存不足了,宁可出现OOM,也不会对其进行回收<br><code>User user = new User()</code></li>
<li>弱引用:表示一个对象处于<strong>可能有用且非必须</strong>的状态,在GC线程扫描内存区域时,一旦发现弱引用,就会回收到弱引用相关联的对象,对于弱引用的回收,无关内存区域是否足够,一旦发现则会被回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>每一个Thread维护一个<code>ThreadLocalMap</code>,在<code>ThreadLocalMap</code>中的Entry对象继承了<code>WeakReference</code>,其中key为使用<strong>弱引用</strong>的ThreadLocal实例,value为线程变量的副本</p>
<p>就是<code>ThreadLocalMap</code>中的key是弱引用,值是强引用,key会被GC释放内存,关联value的内存并不会被释放</p>
<p><strong>防止内存泄漏,要及时使用remove方法</strong></p>
<h1 id="6-JVM篇"><a href="#6-JVM篇" class="headerlink" title="6 JVM篇"></a>6 JVM篇</h1><h2 id="6-1-JVM组成"><a href="#6-1-JVM组成" class="headerlink" title="6.1 JVM组成"></a>6.1 JVM组成</h2><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(PC Register)<br>线程私有的,内部保存的字节码的行号,用于记录正在执行的字节码指令的地址</p>
<p>PC寄存器用来存储指向下一条指令的地址,也就是要执行的指令代码,由执行引擎读取下一条指令</p>
<p><em>这个里面内容挺少的?</em></p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#PC%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B">具体可看这里</a></p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>线程共享的区域,主要用来存储<strong>对象实例,数组</strong>等,当堆中没有内存空间分配给实例,也无法再扩展时,则抛出OutOfMemoryError异常</p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3">具体可看这里</a></p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul>
<li>每个线程运行时所需要的内存,成为虚拟机栈,先进后出</li>
<li>每个栈由多个栈帧(frame)组成,对应着每次方法调用时所占用的内存</li>
<li>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法</li>
</ul>
<p><strong>垃圾回收是否设计栈内存</strong><br>垃圾回收主要指的就是堆内存,当栈帧出栈以后,内存就会释放</p>
<p><strong>栈内存分配越大越好吗</strong><br>未必,默认的栈内存通常为1024KB,栈帧过大会导致线程数变少,例如,及其总内存为512M,目前能活动的线程数则为512个,如果把栈内存改为2048K,那么能活动的栈帧就会减半</p>
<p><strong>方法内的局部变量是否线程安全的</strong></p>
<ul>
<li>如果方法内部局部变量没有逃离方法的作用范围,它是线程安全的</li>
<li>如果是局部变量引用了对象,并逃离方法的作用范围,需要考虑线程安全</li>
</ul>
<p><strong>栈内存溢出情况</strong></p>
<ul>
<li>栈帧过多导致栈内存溢出,比如递归调用</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<p><strong>堆和栈的区别是什么</strong></p>
<ul>
<li>栈内存一般会用来存储局部变量表和方法调用,但堆内存是用来存储Java对象和数组的,堆会GC垃圾回收,而栈不会</li>
<li>栈内存是线程私有的,而堆内存是线程共有的</li>
</ul>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ul>
<li>方法区是各个线程<strong>共享的内存区域</strong></li>
<li>主要存储类的信息,运行时常量池</li>
<li>虚拟机启动的时候创建,关闭虚拟机时释放</li>
<li>如果方法区域中的内存无法满足分配请求,则会抛出OOM:Metaspace</li>
</ul>
<p><strong>常量池</strong><br>可以看作是一张表,虚拟机指令根据这张常量表找到要执行的类名,方法名,参数类型,字面量等信息</p>
<p>而运行时常量池,是在类被加载后,它的常量池信息就会放入运行时常量池,并把里面的符号地址变为真实地址</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存:并不属于JVM中的内存结构,不由JVM进行管理,系统内存,常见于NIO操作时,用于数据缓冲区,它分配回收成本较高,但读写性能高</p>
<h2 id="6-2-类加载器"><a href="#6-2-类加载器" class="headerlink" title="6.2 类加载器"></a>6.2 类加载器</h2><p>主要作用:用于装载字节码文件(.class文件)</p>
<p>JVM只会运行二进制文件,类加载器的作用就是将<strong>字节码文件加载到JVM中</strong>,从而让Java程序能够启动起来</p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB">具体可看这里</a></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>把加载类的请求交给上一级处理</p>
<p>通过双亲委派机制可以避免某一个类被重复加载,当父类已经加载后则无需重复加载,保证唯一性</p>
<p>为了安全,保证类库API不会被修改</p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6">见这里</a></p>
<h3 id="类装载的执行过程"><a href="#类装载的执行过程" class="headerlink" title="类装载的执行过程"></a>类装载的执行过程</h3><p>类从加载到虚拟机中开始,直到卸载为止,它的整个生命周期包括了:加载,验证,准备,解析,初始化,使用和卸载这7个阶段,其中,验证,准备,和解析这三个部分统称为连接(linking)</p>
<ol>
<li><strong>加载</strong><br>通过类的全类名,获取类的二进制数据流<br>解析类的二进制数据流为方法区内的数据结构(Java类模型)<br>创建java.lang.Class类的实例,表示该类型,作为方法区这个类的各种数据的访问入口</li>
<li><strong>验证</strong><br>验证类是否符合JVM规范,安全性检查(格式检查,符号引用验证,常量池中的类&#x2F;方法是否存在)</li>
<li><strong>准备</strong><br>为类变量分配内存并设置类变量初始值<br>static变量,分配空间在准备阶段完成(设置默认值),赋值在初始化阶段完成<br>static变量是final的基本类型,以及字符串常量,值已确定,赋值在准备阶段完成<br>static变量是final的引用类型,那么赋值也会在初始化阶段完成</li>
<li><strong>解析</strong><br>把类中的符号引用转换为直接引用<br>比如:方法中调用了其他方法,方法名可以理解为符号引用,而直接引用就是使用指针直接指向方法</li>
<li><strong>初始化</strong><br>对类的静态变量,静态代码块执行初始化操作<br>如果初始化一个类的时候,其父类尚未初始化,则优先初始化其父类<br>如果同时包含多个静态变量和静态代码块,则按照自上而下的顺序依次执行</li>
<li><strong>使用</strong><br>JVM从入口方法开始执行用户的程序代码</li>
</ol>
<ul>
<li>调用静态类成员信息(比如静态字段,静态方法)</li>
<li>使用new关键字为其创建对象实例</li>
</ul>
<ol start="7">
<li>卸载</li>
</ol>
<h2 id="6-3-垃圾回收"><a href="#6-3-垃圾回收" class="headerlink" title="6.3 垃圾回收"></a>6.3 垃圾回收</h2><p><strong>对象什么时候可以被垃圾回收器回收</strong></p>
<p><strong>如果一个或多个对象没有任何的引用指向它了,那么这个对象现在就是垃圾,如果定位了垃圾,则有可能会被垃圾回收器回收</strong></p>
<p><strong>引用计数法</strong><br>一个对象被引用了一次,在当前的对象头上递增一次引用次数,如果这个对象的引用次数为0,代表这个对象可回收,但是如果对象间出现了循环引用的话,则引用计数法就会失效</p>
<p>还有一种就是<strong>可达性分析算法</strong><br>现在的虚拟机采用的都是通过可达性分析算法来确定哪些内容是垃圾</p>
<ul>
<li>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</li>
<li>扫描堆中的对象,看是否能够沿着GC Root对象为起点的引用链找到该对象,找不到,表示可以回收</li>
</ul>
<hr>
<p><strong>JVM垃圾回收算法有哪些</strong></p>
<ul>
<li>标记清除算法<ul>
<li>根据可达性分析算法得出的垃圾进行标记</li>
<li>对这些标记为可回收的内容进行垃圾回收</li>
<li>优点是标记和清除速度较快,缺点是碎片化较为严重,内存不连贯</li>
</ul>
</li>
<li>标记整理算法(老年代经常使用)<ul>
<li>标记清除之后,会对内存进行整理</li>
<li>对象移动内存位置,其效率有一定影响</li>
</ul>
</li>
<li>复制算法(年轻代经常使用)<ul>
<li>优点就是垃圾较多时,效率较高</li>
<li>清理之后,内存无碎片</li>
<li>缺点就是内存使用率较低</li>
</ul>
</li>
</ul>
<hr>
<p><strong>分代回收</strong></p>
<p>分代,主要是说新生代和老年代<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20231112222814.png" alt="20231112222814"></p>
<p><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#%E5%B9%B4%E8%BD%BB%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3">看这里</a></p>
<hr>
<p><strong>JVM中的垃圾回收期</strong></p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS(并发)垃圾收集器</li>
<li>G1垃圾收集器</li>
</ul>
<p><strong>串行垃圾收集器</strong><br>Serial和Serial Old串行垃圾收集器,是指使用单线程进行垃圾回收,堆内存较小,适合个人电脑</p>
<ul>
<li><code>Serial</code>作用于新生代,采用复制算法</li>
<li><code>Serial Old</code>作用于老年代,采用标记-整理算法<br>垃圾回收时,只有一个线程在工作,并且Java应用中的所有线程都要暂停(STW),等待垃圾回收的完成</li>
</ul>
<p><strong>并行垃圾收集器</strong><br>Parallel New和Parallel Old是一个并行垃圾回收器,<strong>JDK默认使用此垃圾回收器</strong></p>
<ul>
<li>Parallel New作用于新生代,采用复制算法</li>
<li>Parallel Old作用于老年代,采用标记-整理算法<br>垃圾回收时,多个线程在工作,并且Java应用中的所有线程都要暂停(STW),等待垃圾回收的完成</li>
</ul>
<p><strong>CMS(并发)垃圾收集器</strong><br>CMS全称Concurrent Mark Sweep,是一款并发的,使用<strong>标记-清除</strong>算法的垃圾回收器,该回收器是针对老年代垃圾回收的,是一款以获取最短回收停顿时间为目标的收集器,停顿时间短,用户体验好,其最大特点是在进行垃圾回收时,应用仍然能正常运行</p>
<hr>
<p><strong>G1垃圾收集器</strong></p>
<ul>
<li>应用于新生代和老年代,在JDK9之后默认使用G1</li>
<li>划分为多个区域,每个区域都可以充当eden,survivor,old,humongous,其中humongous转为大对象准备</li>
<li>采用复制算法</li>
<li>响应时间与吞吐量兼顾</li>
<li>分成三个阶段,新生代回收(STW),并发标记(重新标记STW),混合收集</li>
<li>如果并发失败(即回收速度赶不上创建新对象速度),会触发Full GC</li>
</ul>
<hr>
<p><strong>强引用,软引用,弱引用,虚引用的区别</strong></p>
<ul>
<li>强引用:只有当所有GC Roots对象都不能通过强引用引用该对象,该对象才能被垃圾回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20231113100017.png" alt="20231113100017"></li>
<li>软引用:仅有软引用引用该对象时,在垃圾回收后,内存仍不足时才会再次触发垃圾回收<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">SoftReference</span> <span class="variable">softReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SoftReference</span>(user);</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20231113100200.png" alt="20231113100200"></li>
<li>弱引用:仅有弱引用引用该对象时,<strong>在垃圾回收时,无论内存是否充足</strong>,都会回收弱引用对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>()</span><br><span class="line"><span class="type">WeakReference</span> <span class="variable">weakReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakReference</span>(user);</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/20231113100342.png" alt="20231113100342"></li>
<li>虚引用:必须配合引用队列使用,被引用对象回收时,会将虚引用入队,由Reference Handler线程调用虚引用相关方法释放直接内存<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">referenceQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="type">PhantomReference</span> <span class="variable">phantomReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhantomReference</span>(user.queue);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-4-JVM实践"><a href="#6-4-JVM实践" class="headerlink" title="6.4 JVM实践"></a>6.4 JVM实践</h2><p><strong>JVM调优的参数可以在哪里设置</strong></p>
<ol>
<li>war包形式,在tomcat中设置,修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1300955.jpg" alt="2023-11-1300955"></li>
<li>jar包形式,通常在linux系统下直接加参数启动springboot项目<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-1301132.jpg" alt="2023-11-1301132"></li>
</ol>
<hr>
<p><strong>JVM调优的参数都有哪些</strong><br>对于JVM调优,主要就是调整年轻代,老年代,元空间的内存空间大小及使用的垃圾回收器类型<br><a target="_blank" rel="noopener" href="https://blog.zzmr.club/posts/28becffb.html#%E5%B0%8F%E7%BB%93%E5%A0%86%E7%A9%BA%E9%97%B4%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE">参考这里</a></p>
<p>关于虚拟机栈也可以调整,每个线程默认会开启1MB的内存,用于存放栈帧,调用参数,局部变量等,但一般256K就足够,通常减少每个线程的堆栈,可以产生更多的线程,但这实际上还受限于操作系统<br><code>-Xss 对每个线程stack大小的调整-Xss128k</code></p>
<p>设置垃圾回收器,通过增大吞吐量提高系统性能,可以通过设置并行垃圾回收器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParalleOldGC</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用G1GC</span></span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>

<hr>
<p>JVM常用的命令工具<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/2023-11-102050.jpg" alt="2023-11-102050"></p>
<hr>
<p><strong>Java内存泄漏的排查思路</strong><br>运行时数据区中,有3块可能发生内存泄漏</p>
<ol>
<li>虚拟机栈</li>
<li>堆</li>
<li>方法区&#x2F;元空间</li>
</ol>
<p><strong>排查方案</strong></p>
<ol>
<li>获取堆内存快照dump</li>
<li>VisualVM去分析dump文件</li>
<li>通过查看堆信息的情况,定位内存溢出的问题</li>
</ol>
<hr>
<p><strong>CPU飙高排查方案与思路</strong><br>首先使用top命令查看具体的进程id<br>然后使用<code>ps H -eo pid,tid,%cpu | grep 2266</code><br>就可以查询到该进程对应的所有线程占用情况</p>
<p>再使用jstack 2266,再找到线程id(注意,2266是10进制,jstack中是十六进制)</p>
<p>就可以找到问题所在了</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">定西</div><div class="post-copyright__author_desc">桃之夭夭，灼灼其华</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://jimmy66886.github.io/posts/7b3d68.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://jimmy66886.github.io/posts/7b3d68.html')">Java八股文</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://img01.zzmr.club/img/chatpay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/chatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://img01.zzmr.club/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://jimmy66886.github.io/posts/7b3d68.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Java八股文&amp;url=https://jimmy66886.github.io/posts/7b3d68.html&amp;pic=https://img01.zzmr.club/img/拾光_贪食鬼_6652.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jimmy66886.github.io" target="_blank">ZZMR</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">7</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://img01.zzmr.club/img/Courseplan.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/4614ec31.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/拾光_拾光_1084.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis面经</div></div></a></div><div class="next-post pull-right"><a href="/posts/a91f5ba1.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/DSC08725.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">索引的数据结构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>猜你喜欢</span></div><div class="relatedPosts-list"><div><a href="/posts/b0e1545b.html" title="Mysql面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/拾光_贪食鬼_6684.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-10</div><div class="title">Mysql面经</div></div></a></div><div><a href="/posts/4614ec31.html" title="Redis面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/拾光_拾光_1084.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-26</div><div class="title">Redis面经</div></div></a></div><div><a href="/posts/3204244d.html" title="JVM面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/jvm面经.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-13</div><div class="title">JVM面经</div></div></a></div><div><a href="/posts/1e320f13.html" title="框架面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/logo (4).png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-10</div><div class="title">框架面经</div></div></a></div><div><a href="/posts/d43ca8a9.html" title="并发编程面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/并发编程logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-11-12</div><div class="title">并发编程面经</div></div></a></div><div><a href="/posts/72387302.html" title="集合面经"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/logo_list.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-10</div><div class="title">集合面经</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar" title="点击展开"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">都是学习笔记和生活琐事<b style="color:#fff"></b><b style="color:#fff">行之所向,即心之所向</b><b style="color:#fff"></b></div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);"><b style="color:#fff"></b><b style="color:#fff"></b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">定西</h1><div class="author-info__desc">桃之夭夭，灼灼其华</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/jimmy66886/" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Redis%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">1 Redis篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 缓存穿透</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 缓存雪崩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 双写一致</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%A6%81%E6%B1%82%E9%AB%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">一致性要求高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E5%BB%B6%E8%BF%9F%E4%B8%80%E8%87%B4"><span class="toc-number">1.4.2.</span> <span class="toc-text">允许延迟一致</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB"><span class="toc-number">1.5.1.</span> <span class="toc-text">RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF"><span class="toc-number">1.5.2.</span> <span class="toc-text">AOF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">定期删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 淘汰策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.8.</span> <span class="toc-text">1.8 分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">1.9.</span> <span class="toc-text">1.9 集群方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.9.1.</span> <span class="toc-text">主从复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.2.</span> <span class="toc-text">哨兵模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.3.</span> <span class="toc-text">分片集群结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Redis%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">1.10 Redis其他问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">2 数据库篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BC%98%E5%8C%96%E7%AF%87"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 优化篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 其他面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">2.2.1.</span> <span class="toc-text">事务相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.2.</span> <span class="toc-text">主从同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">分库分表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%A1%86%E6%9E%B6%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">3 框架篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Spring"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Spring</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-SpringMVC"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">视图阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%98%B6%E6%AE%B5-%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">3.2.2.</span> <span class="toc-text">前后端分离阶段(接口开发,异步请求)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-SpringBoot"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 SpringBoot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-MyBatis"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 MyBatis</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E9%9B%86%E5%90%88%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">4 集合篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%95%B0%E7%BB%84"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">数组结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.2.</span> <span class="toc-text">ArrayList源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">ArrayList面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%93%BE%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.1.</span> <span class="toc-text">链表结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">4.4.1.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">4.4.2.</span> <span class="toc-text">红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.4 散列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E9%93%BE%E8%A1%A8%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">4.5 链表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-HashMap%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.7.</span> <span class="toc-text">4.6 HashMap面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put%E6%BA%90%E7%A0%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">put源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%BA%90%E7%A0%81"><span class="toc-number">4.7.2.</span> <span class="toc-text">扩容源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E6%BA%90%E7%A0%81"><span class="toc-number">4.7.3.</span> <span class="toc-text">get源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.7.4.</span> <span class="toc-text">其他面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text">5 并发编程篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 线程的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 线程中并发安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM"><span class="toc-number">5.2.1.</span> <span class="toc-text">JMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-number">5.2.2.</span> <span class="toc-text">CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.2.3.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">5.2.4.</span> <span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.5.</span> <span class="toc-text">ReentrantLock的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock"><span class="toc-number">5.2.6.</span> <span class="toc-text">lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.7.</span> <span class="toc-text">死锁产生条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">5.2.8.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%87%B4%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.2.9.</span> <span class="toc-text">导致并发程序出现问题的根本原因是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">5.3.1.</span> <span class="toc-text">线程池的核心参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">5.3.2.</span> <span class="toc-text">阻塞队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">5.3.3.</span> <span class="toc-text">如何确定核心线程数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">5.3.4.</span> <span class="toc-text">线程池的种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-ThreadLocal"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-JVM%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">6 JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-JVM%E7%BB%84%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">6.1.1.</span> <span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">6.1.2.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">6.1.3.</span> <span class="toc-text">虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">6.1.4.</span> <span class="toc-text">方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">6.1.5.</span> <span class="toc-text">直接内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.1.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.2.</span> <span class="toc-text">类装载的执行过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-JVM%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 JVM实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/cf408691.html" title="毕设规划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/Courseplan.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="毕设规划"/></a><div class="content"><a class="title" href="/posts/cf408691.html" title="毕设规划">毕设规划</a><time datetime="2024-01-11T04:27:50.000Z" title="发表于 2024-01-11 12:27:50">2024-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/9f786011.html" title="Collection与Map"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/collectionandmap.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Collection与Map"/></a><div class="content"><a class="title" href="/posts/9f786011.html" title="Collection与Map">Collection与Map</a><time datetime="2023-11-15T14:24:34.000Z" title="发表于 2023-11-15 22:24:34">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4f8e0775.html" title="Java比较器"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/bijiaoqi.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java比较器"/></a><div class="content"><a class="title" href="/posts/4f8e0775.html" title="Java比较器">Java比较器</a><time datetime="2023-11-15T05:03:25.000Z" title="发表于 2023-11-15 13:03:25">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3204244d.html" title="JVM面经"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/jvm面经.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM面经"/></a><div class="content"><a class="title" href="/posts/3204244d.html" title="JVM面经">JVM面经</a><time datetime="2023-11-13T02:49:36.000Z" title="发表于 2023-11-13 10:49:36">2023-11-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/d43ca8a9.html" title="并发编程面经"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/并发编程logo.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程面经"/></a><div class="content"><a class="title" href="/posts/d43ca8a9.html" title="并发编程面经">并发编程面经</a><time datetime="2023-11-12T09:49:15.000Z" title="发表于 2023-11-12 17:49:15">2023-11-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.3.0" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v6.3.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站使用vercel托管部署" title="本站使用vercel托管部署"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/Hosted-Vercel.svg" alt="本站使用vercel托管部署"/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站由jsDelivr托管CDN" title="本站由jsDelivr托管CDN"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img01.zzmr.club/img/CDN-jsDelivr.svg" alt="本站由jsDelivr托管CDN"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20238040" style="margin-inline:5px" data-title="萌ICP备20238040号" title="萌ICP备20238040号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.shields.io/badge/%E8%90%8CICP%E5%A4%87-20238040-fe1384" alt="萌ICP备20238040号"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="定西" target="_blank">定西</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s2.loli.net/2022/09/02/6rUxGoewvp5hNlB.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/maps/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 导航</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-dice-d20 faa-tada" style="font-size: 0.9em;"></i><span> 游戏人生</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/staticIndex/test.html"><i class="anzhiyufont anzhiyu-icon-rocket faa-tada" style="font-size: 0.9em;"></i><span> 舔狗日记</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AOP/" style="font-size: 0.88rem;">AOP<sup>1</sup></a><a href="/tags/Ajax/" style="font-size: 0.88rem;">Ajax<sup>1</sup></a><a href="/tags/Algolia/" style="font-size: 0.88rem;">Algolia<sup>1</sup></a><a href="/tags/Axios/" style="font-size: 0.88rem;">Axios<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>1</sup></a><a href="/tags/MySql/" style="font-size: 0.88rem;">MySql<sup>2</sup></a><a href="/tags/Promise/" style="font-size: 0.88rem;">Promise<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem;">Redis<sup>1</sup></a><a href="/tags/SSM/" style="font-size: 0.88rem;">SSM<sup>3</sup></a><a href="/tags/Shell/" style="font-size: 0.88rem;">Shell<sup>1</sup></a><a href="/tags/SpingBoot/" style="font-size: 0.88rem;">SpingBoot<sup>1</sup></a><a href="/tags/SpringCloud/" style="font-size: 0.88rem;">SpringCloud<sup>1</sup></a><a href="/tags/VsCode/" style="font-size: 0.88rem;">VsCode<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 0.88rem;">Vue<sup>1</sup></a><a href="/tags/mag68/" style="font-size: 0.88rem;">mag68<sup>1</sup></a><a href="/tags/maven/" style="font-size: 0.88rem;">maven<sup>1</sup></a><a href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" style="font-size: 0.88rem;">主从复制<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>1</sup></a><a href="/tags/%E5%9F%9F%E5%90%8D/" style="font-size: 0.88rem;">域名<sup>1</sup></a><a href="/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" style="font-size: 0.88rem;">年度总结<sup>1</sup></a><a href="/tags/%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">开发<sup>1</sup></a><a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 0.88rem;">排序<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem;">旅行<sup>5</sup></a><a href="/tags/%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">杂谈<sup>1</sup></a><a href="/tags/%E6%A0%87%E7%AD%BE%E5%A4%96%E6%8C%82/" style="font-size: 0.88rem;">标签外挂<sup>1</sup></a><a href="/tags/%E6%AF%95%E8%AE%BE/" style="font-size: 0.88rem;">毕设<sup>1</sup></a><a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">线程<sup>1</sup></a><a href="/tags/%E7%BE%8E%E5%8C%96/" style="font-size: 0.88rem;">美化<sup>1</sup></a><a href="/tags/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96/" style="font-size: 0.88rem;">苍穹外卖<sup>1</sup></a><a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 0.88rem;">集合<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>7</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/02/2022 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.1",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      "color:#3b70fc",
      "",
      "color:#3b70fc",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 定西 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.56.5/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.zzmr.club/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.zzmr.club/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.zzmr.club/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "visitor@anheyu.com";</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>